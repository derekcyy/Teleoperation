# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class TurtleBotActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TurtleBot]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TurtleBot.prisma().query_raw(
            'SELECT * FROM TurtleBot WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TurtleBot
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TurtleBot.prisma().query_first(
            'SELECT * FROM TurtleBot WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TurtleBotCreateInput,
        include: Optional[types.TurtleBotInclude] = None
    ) -> _PrismaModelT:
        """Create a new TurtleBot record.

        Parameters
        ----------
        data
            TurtleBot record data
        include
            Specifies which relations should be loaded on the returned TurtleBot model

        Returns
        -------
        prisma.models.TurtleBot
            The created TurtleBot record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TurtleBot record from just the required fields
        turtlebot = await TurtleBot.prisma().create(
            data={
                # data to create a TurtleBot record
                'name': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TurtleBotCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TurtleBot records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TurtleBot record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TurtleBot.prisma().create_many(
            data=[
                {
                    # data to create a TurtleBot record
                    'name': 'bbehjachib',
                },
                {
                    # data to create a TurtleBot record
                    'name': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TurtleBotWhereUniqueInput,
        include: Optional[types.TurtleBotInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TurtleBot record.

        Parameters
        ----------
        where
            TurtleBot filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TurtleBot model

        Returns
        -------
        prisma.models.TurtleBot
            The deleted TurtleBot record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        turtlebot = await TurtleBot.prisma().delete(
            where={
                'id': 368800899,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TurtleBotWhereUniqueInput,
        include: Optional[types.TurtleBotInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TurtleBot record.

        Parameters
        ----------
        where
            TurtleBot filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TurtleBot model

        Returns
        -------
        prisma.models.TurtleBot
            The found TurtleBot record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        turtlebot = await TurtleBot.prisma().find_unique(
            where={
                'id': 1508029952,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TurtleBotWhereUniqueInput,
        include: Optional[types.TurtleBotInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TurtleBot record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TurtleBot filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TurtleBot model

        Returns
        -------
        prisma.models.TurtleBot
            The found TurtleBot record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        turtlebot = await TurtleBot.prisma().find_unique_or_raise(
            where={
                'id': 486256185,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TurtleBotWhereInput] = None,
        cursor: Optional[types.TurtleBotWhereUniqueInput] = None,
        include: Optional[types.TurtleBotInclude] = None,
        order: Optional[Union[types.TurtleBotOrderByInput, List[types.TurtleBotOrderByInput]]] = None,
        distinct: Optional[List[types.TurtleBotScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TurtleBot records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TurtleBot records returned
        skip
            Ignore the first N results
        where
            TurtleBot filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TurtleBot model
        order
            Order the returned TurtleBot records by any field
        distinct
            Filter TurtleBot records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TurtleBot]
            The list of all TurtleBot records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TurtleBot records
        turtlebots = await TurtleBot.prisma().find_many(take=10)

        # find the first 5 TurtleBot records ordered by the createdAt field
        turtlebots = await TurtleBot.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TurtleBotWhereInput] = None,
        cursor: Optional[types.TurtleBotWhereUniqueInput] = None,
        include: Optional[types.TurtleBotInclude] = None,
        order: Optional[Union[types.TurtleBotOrderByInput, List[types.TurtleBotOrderByInput]]] = None,
        distinct: Optional[List[types.TurtleBotScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TurtleBot record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TurtleBot filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TurtleBot model
        order
            Order the returned TurtleBot records by any field
        distinct
            Filter TurtleBot records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TurtleBot
            The first TurtleBot record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TurtleBot record ordered by the id field
        turtlebot = await TurtleBot.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TurtleBotWhereInput] = None,
        cursor: Optional[types.TurtleBotWhereUniqueInput] = None,
        include: Optional[types.TurtleBotInclude] = None,
        order: Optional[Union[types.TurtleBotOrderByInput, List[types.TurtleBotOrderByInput]]] = None,
        distinct: Optional[List[types.TurtleBotScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TurtleBot record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TurtleBot filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TurtleBot model
        order
            Order the returned TurtleBot records by any field
        distinct
            Filter TurtleBot records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TurtleBot
            The first TurtleBot record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TurtleBot record ordered by the name field
        turtlebot = await TurtleBot.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TurtleBotUpdateInput,
        where: types.TurtleBotWhereUniqueInput,
        include: Optional[types.TurtleBotInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TurtleBot record.

        Parameters
        ----------
        data
            TurtleBot record data specifying what to update
        where
            TurtleBot filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TurtleBot model

        Returns
        -------
        prisma.models.TurtleBot
            The updated TurtleBot record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        turtlebot = await TurtleBot.prisma().update(
            where={
                'id': 1062517886,
            },
            data={
                # data to update the TurtleBot record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TurtleBotWhereUniqueInput,
        data: types.TurtleBotUpsertInput,
        include: Optional[types.TurtleBotInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TurtleBot filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TurtleBot model

        Returns
        -------
        prisma.models.TurtleBot
            The created or updated TurtleBot record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        turtlebot = await TurtleBot.prisma().upsert(
            where={
                'id': 267834847,
            },
            data={
                'create': {
                    'id': 267834847,
                    'name': 'cadfabfehe',
                },
                'update': {
                    'name': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TurtleBotUpdateManyMutationInput,
        where: types.TurtleBotWhereInput,
    ) -> int:
        """Update multiple TurtleBot records

        Parameters
        ----------
        data
            TurtleBot data to update the selected TurtleBot records to
        where
            Filter to select the TurtleBot records to update

        Returns
        -------
        int
            The total number of TurtleBot records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TurtleBot records
        total = await TurtleBot.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TurtleBotWhereInput] = None,
        cursor: Optional[types.TurtleBotWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TurtleBot records present in the database

        Parameters
        ----------
        select
            Select the TurtleBot fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TurtleBot filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TurtleBotCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TurtleBot.prisma().count()

        # results: prisma.types.TurtleBotCountAggregateOutput
        results = await TurtleBot.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TurtleBotCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TurtleBotWhereInput] = None,
        cursor: Optional[types.TurtleBotWhereUniqueInput] = None,
    ) -> types.TurtleBotCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TurtleBotCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TurtleBotWhereInput] = None,
        cursor: Optional[types.TurtleBotWhereUniqueInput] = None,
    ) -> Union[int, types.TurtleBotCountAggregateOutput]:
        """Count the number of TurtleBot records present in the database

        Parameters
        ----------
        select
            Select the TurtleBot fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TurtleBot filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TurtleBotCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TurtleBot.prisma().count()

        # results: prisma.types.TurtleBotCountAggregateOutput
        results = await TurtleBot.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TurtleBotCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TurtleBotWhereInput] = None
    ) -> int:
        """Delete multiple TurtleBot records.

        Parameters
        ----------
        where
            Optional TurtleBot filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TurtleBot records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TurtleBot records
        total = await TurtleBot.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TurtleBotScalarFieldKeys'],
        *,
        where: Optional['types.TurtleBotWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TurtleBotAvgAggregateInput'] = None,
        sum: Optional['types.TurtleBotSumAggregateInput'] = None,
        min: Optional['types.TurtleBotMinAggregateInput'] = None,
        max: Optional['types.TurtleBotMaxAggregateInput'] = None,
        having: Optional['types.TurtleBotScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TurtleBotCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TurtleBotScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TurtleBotScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TurtleBotGroupByOutput']:
        """Group TurtleBot records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TurtleBot fields to group records by
        where
            TurtleBot filter to select records
        take
            Limit the maximum number of TurtleBot records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TurtleBotGroupByOutput]
            A list of dictionaries representing the TurtleBot record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TurtleBot records by createdAt values
        # and count how many records are in each group
        results = await TurtleBot.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TelemetryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Telemetry]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Telemetry.prisma().query_raw(
            'SELECT * FROM Telemetry WHERE id = $1',
            180171308,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Telemetry
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Telemetry.prisma().query_first(
            'SELECT * FROM Telemetry WHERE turtleBotId = $1',
            836760821,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TelemetryCreateInput,
        include: Optional[types.TelemetryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Telemetry record.

        Parameters
        ----------
        data
            Telemetry record data
        include
            Specifies which relations should be loaded on the returned Telemetry model

        Returns
        -------
        prisma.models.Telemetry
            The created Telemetry record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Telemetry record from just the required fields
        telemetry = await Telemetry.prisma().create(
            data={
                # data to create a Telemetry record
                'turtleBotId': 595337866,
                'timestamp': datetime.datetime.utcnow(),
                'x': 790425851.211191,
                'y': 1149758321.164428,
                'heading': 1388290519.164741,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TelemetryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Telemetry records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Telemetry record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Telemetry.prisma().create_many(
            data=[
                {
                    # data to create a Telemetry record
                    'turtleBotId': 1675546029,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 1767274722.32627,
                    'y': 1343201072.67578,
                    'heading': 744964398.196968,
                },
                {
                    # data to create a Telemetry record
                    'turtleBotId': 1116175964,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 861472101.130300,
                    'y': 1686638315.200043,
                    'heading': 1868141281.186084,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TelemetryWhereUniqueInput,
        include: Optional[types.TelemetryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Telemetry record.

        Parameters
        ----------
        where
            Telemetry filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Telemetry model

        Returns
        -------
        prisma.models.Telemetry
            The deleted Telemetry record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        telemetry = await Telemetry.prisma().delete(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TelemetryWhereUniqueInput,
        include: Optional[types.TelemetryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Telemetry record.

        Parameters
        ----------
        where
            Telemetry filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Telemetry model

        Returns
        -------
        prisma.models.Telemetry
            The found Telemetry record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        telemetry = await Telemetry.prisma().find_unique(
            where={
                'id': 1628650740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TelemetryWhereUniqueInput,
        include: Optional[types.TelemetryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Telemetry record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Telemetry filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Telemetry model

        Returns
        -------
        prisma.models.Telemetry
            The found Telemetry record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        telemetry = await Telemetry.prisma().find_unique_or_raise(
            where={
                'id': 1249606685,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TelemetryWhereInput] = None,
        cursor: Optional[types.TelemetryWhereUniqueInput] = None,
        include: Optional[types.TelemetryInclude] = None,
        order: Optional[Union[types.TelemetryOrderByInput, List[types.TelemetryOrderByInput]]] = None,
        distinct: Optional[List[types.TelemetryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Telemetry records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Telemetry records returned
        skip
            Ignore the first N results
        where
            Telemetry filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Telemetry model
        order
            Order the returned Telemetry records by any field
        distinct
            Filter Telemetry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Telemetry]
            The list of all Telemetry records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Telemetry records
        telemetrys = await Telemetry.prisma().find_many(take=10)

        # find the first 5 Telemetry records ordered by the timestamp field
        telemetrys = await Telemetry.prisma().find_many(
            take=5,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TelemetryWhereInput] = None,
        cursor: Optional[types.TelemetryWhereUniqueInput] = None,
        include: Optional[types.TelemetryInclude] = None,
        order: Optional[Union[types.TelemetryOrderByInput, List[types.TelemetryOrderByInput]]] = None,
        distinct: Optional[List[types.TelemetryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Telemetry record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Telemetry filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Telemetry model
        order
            Order the returned Telemetry records by any field
        distinct
            Filter Telemetry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Telemetry
            The first Telemetry record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Telemetry record ordered by the x field
        telemetry = await Telemetry.prisma().find_first(
            skip=1,
            order={
                'x': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TelemetryWhereInput] = None,
        cursor: Optional[types.TelemetryWhereUniqueInput] = None,
        include: Optional[types.TelemetryInclude] = None,
        order: Optional[Union[types.TelemetryOrderByInput, List[types.TelemetryOrderByInput]]] = None,
        distinct: Optional[List[types.TelemetryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Telemetry record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Telemetry filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Telemetry model
        order
            Order the returned Telemetry records by any field
        distinct
            Filter Telemetry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Telemetry
            The first Telemetry record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Telemetry record ordered by the y field
        telemetry = await Telemetry.prisma().find_first_or_raise(
            skip=1,
            order={
                'y': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TelemetryUpdateInput,
        where: types.TelemetryWhereUniqueInput,
        include: Optional[types.TelemetryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Telemetry record.

        Parameters
        ----------
        data
            Telemetry record data specifying what to update
        where
            Telemetry filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Telemetry model

        Returns
        -------
        prisma.models.Telemetry
            The updated Telemetry record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        telemetry = await Telemetry.prisma().update(
            where={
                'id': 835903122,
            },
            data={
                # data to update the Telemetry record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TelemetryWhereUniqueInput,
        data: types.TelemetryUpsertInput,
        include: Optional[types.TelemetryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Telemetry filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Telemetry model

        Returns
        -------
        prisma.models.Telemetry
            The created or updated Telemetry record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        telemetry = await Telemetry.prisma().upsert(
            where={
                'id': 763719779,
            },
            data={
                'create': {
                    'id': 763719779,
                    'turtleBotId': 1116175964,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 861472101.130300,
                    'y': 1686638315.200043,
                    'heading': 1868141281.186084,
                },
                'update': {
                    'turtleBotId': 1116175964,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 861472101.130300,
                    'y': 1686638315.200043,
                    'heading': 1868141281.186084,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TelemetryUpdateManyMutationInput,
        where: types.TelemetryWhereInput,
    ) -> int:
        """Update multiple Telemetry records

        Parameters
        ----------
        data
            Telemetry data to update the selected Telemetry records to
        where
            Filter to select the Telemetry records to update

        Returns
        -------
        int
            The total number of Telemetry records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Telemetry records
        total = await Telemetry.prisma().update_many(
            data={
                'heading': 429995104.177581
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TelemetryWhereInput] = None,
        cursor: Optional[types.TelemetryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Telemetry records present in the database

        Parameters
        ----------
        select
            Select the Telemetry fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Telemetry filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TelemetryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Telemetry.prisma().count()

        # results: prisma.types.TelemetryCountAggregateOutput
        results = await Telemetry.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TelemetryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TelemetryWhereInput] = None,
        cursor: Optional[types.TelemetryWhereUniqueInput] = None,
    ) -> types.TelemetryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TelemetryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TelemetryWhereInput] = None,
        cursor: Optional[types.TelemetryWhereUniqueInput] = None,
    ) -> Union[int, types.TelemetryCountAggregateOutput]:
        """Count the number of Telemetry records present in the database

        Parameters
        ----------
        select
            Select the Telemetry fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Telemetry filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TelemetryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Telemetry.prisma().count()

        # results: prisma.types.TelemetryCountAggregateOutput
        results = await Telemetry.prisma().count(
            select={
                '_all': True,
                'turtleBotId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TelemetryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TelemetryWhereInput] = None
    ) -> int:
        """Delete multiple Telemetry records.

        Parameters
        ----------
        where
            Optional Telemetry filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Telemetry records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Telemetry records
        total = await Telemetry.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TelemetryScalarFieldKeys'],
        *,
        where: Optional['types.TelemetryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TelemetryAvgAggregateInput'] = None,
        sum: Optional['types.TelemetrySumAggregateInput'] = None,
        min: Optional['types.TelemetryMinAggregateInput'] = None,
        max: Optional['types.TelemetryMaxAggregateInput'] = None,
        having: Optional['types.TelemetryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TelemetryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TelemetryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TelemetryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TelemetryGroupByOutput']:
        """Group Telemetry records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Telemetry fields to group records by
        where
            Telemetry filter to select records
        take
            Limit the maximum number of Telemetry records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TelemetryGroupByOutput]
            A list of dictionaries representing the Telemetry record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Telemetry records by timestamp values
        # and count how many records are in each group
        results = await Telemetry.prisma().group_by(
            ['timestamp'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BatteryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Battery]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Battery.prisma().query_raw(
            'SELECT * FROM Battery WHERE id = $1',
            893145566,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Battery
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Battery.prisma().query_first(
            'SELECT * FROM Battery WHERE turtleBotId = $1',
            995405759,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BatteryCreateInput,
        include: Optional[types.BatteryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Battery record.

        Parameters
        ----------
        data
            Battery record data
        include
            Specifies which relations should be loaded on the returned Battery model

        Returns
        -------
        prisma.models.Battery
            The created Battery record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Battery record from just the required fields
        battery = await Battery.prisma().create(
            data={
                # data to create a Battery record
                'turtleBotId': 2102736524,
                'timestamp': datetime.datetime.utcnow(),
                'voltage': 271520213.45663,
                'current': 2058258651.158368,
                'percentage': 878442065.167528,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BatteryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Battery records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Battery record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Battery.prisma().create_many(
            data=[
                {
                    # data to create a Battery record
                    'turtleBotId': 1627576247,
                    'timestamp': datetime.datetime.utcnow(),
                    'voltage': 2054802212.6033,
                    'current': 684462146.162550,
                    'percentage': 521827728.126603,
                },
                {
                    # data to create a Battery record
                    'turtleBotId': 93253262,
                    'timestamp': datetime.datetime.utcnow(),
                    'voltage': 2053047983.68533,
                    'current': 127474245.94892,
                    'percentage': 1964990155.122889,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BatteryWhereUniqueInput,
        include: Optional[types.BatteryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Battery record.

        Parameters
        ----------
        where
            Battery filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Battery model

        Returns
        -------
        prisma.models.Battery
            The deleted Battery record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        battery = await Battery.prisma().delete(
            where={
                'id': 255202753,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BatteryWhereUniqueInput,
        include: Optional[types.BatteryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Battery record.

        Parameters
        ----------
        where
            Battery filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Battery model

        Returns
        -------
        prisma.models.Battery
            The found Battery record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        battery = await Battery.prisma().find_unique(
            where={
                'id': 1223573862,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BatteryWhereUniqueInput,
        include: Optional[types.BatteryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Battery record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Battery filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Battery model

        Returns
        -------
        prisma.models.Battery
            The found Battery record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        battery = await Battery.prisma().find_unique_or_raise(
            where={
                'id': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryWhereInput] = None,
        cursor: Optional[types.BatteryWhereUniqueInput] = None,
        include: Optional[types.BatteryInclude] = None,
        order: Optional[Union[types.BatteryOrderByInput, List[types.BatteryOrderByInput]]] = None,
        distinct: Optional[List[types.BatteryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Battery records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Battery records returned
        skip
            Ignore the first N results
        where
            Battery filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Battery model
        order
            Order the returned Battery records by any field
        distinct
            Filter Battery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Battery]
            The list of all Battery records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Battery records
        batterys = await Battery.prisma().find_many(take=10)

        # find the first 5 Battery records ordered by the timestamp field
        batterys = await Battery.prisma().find_many(
            take=5,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BatteryWhereInput] = None,
        cursor: Optional[types.BatteryWhereUniqueInput] = None,
        include: Optional[types.BatteryInclude] = None,
        order: Optional[Union[types.BatteryOrderByInput, List[types.BatteryOrderByInput]]] = None,
        distinct: Optional[List[types.BatteryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Battery record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Battery filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Battery model
        order
            Order the returned Battery records by any field
        distinct
            Filter Battery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Battery
            The first Battery record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Battery record ordered by the voltage field
        battery = await Battery.prisma().find_first(
            skip=1,
            order={
                'voltage': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BatteryWhereInput] = None,
        cursor: Optional[types.BatteryWhereUniqueInput] = None,
        include: Optional[types.BatteryInclude] = None,
        order: Optional[Union[types.BatteryOrderByInput, List[types.BatteryOrderByInput]]] = None,
        distinct: Optional[List[types.BatteryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Battery record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Battery filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Battery model
        order
            Order the returned Battery records by any field
        distinct
            Filter Battery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Battery
            The first Battery record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Battery record ordered by the current field
        battery = await Battery.prisma().find_first_or_raise(
            skip=1,
            order={
                'current': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BatteryUpdateInput,
        where: types.BatteryWhereUniqueInput,
        include: Optional[types.BatteryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Battery record.

        Parameters
        ----------
        data
            Battery record data specifying what to update
        where
            Battery filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Battery model

        Returns
        -------
        prisma.models.Battery
            The updated Battery record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        battery = await Battery.prisma().update(
            where={
                'id': 1064846676,
            },
            data={
                # data to update the Battery record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BatteryWhereUniqueInput,
        data: types.BatteryUpsertInput,
        include: Optional[types.BatteryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Battery filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Battery model

        Returns
        -------
        prisma.models.Battery
            The created or updated Battery record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        battery = await Battery.prisma().upsert(
            where={
                'id': 508382461,
            },
            data={
                'create': {
                    'id': 508382461,
                    'turtleBotId': 93253262,
                    'timestamp': datetime.datetime.utcnow(),
                    'voltage': 2053047983.68533,
                    'current': 127474245.94892,
                    'percentage': 1964990155.122889,
                },
                'update': {
                    'turtleBotId': 93253262,
                    'timestamp': datetime.datetime.utcnow(),
                    'voltage': 2053047983.68533,
                    'current': 127474245.94892,
                    'percentage': 1964990155.122889,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BatteryUpdateManyMutationInput,
        where: types.BatteryWhereInput,
    ) -> int:
        """Update multiple Battery records

        Parameters
        ----------
        data
            Battery data to update the selected Battery records to
        where
            Filter to select the Battery records to update

        Returns
        -------
        int
            The total number of Battery records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Battery records
        total = await Battery.prisma().update_many(
            data={
                'percentage': 1024265714.87207
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryWhereInput] = None,
        cursor: Optional[types.BatteryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Battery records present in the database

        Parameters
        ----------
        select
            Select the Battery fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Battery filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BatteryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Battery.prisma().count()

        # results: prisma.types.BatteryCountAggregateOutput
        results = await Battery.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BatteryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryWhereInput] = None,
        cursor: Optional[types.BatteryWhereUniqueInput] = None,
    ) -> types.BatteryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BatteryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryWhereInput] = None,
        cursor: Optional[types.BatteryWhereUniqueInput] = None,
    ) -> Union[int, types.BatteryCountAggregateOutput]:
        """Count the number of Battery records present in the database

        Parameters
        ----------
        select
            Select the Battery fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Battery filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BatteryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Battery.prisma().count()

        # results: prisma.types.BatteryCountAggregateOutput
        results = await Battery.prisma().count(
            select={
                '_all': True,
                'turtleBotId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BatteryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BatteryWhereInput] = None
    ) -> int:
        """Delete multiple Battery records.

        Parameters
        ----------
        where
            Optional Battery filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Battery records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Battery records
        total = await Battery.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BatteryScalarFieldKeys'],
        *,
        where: Optional['types.BatteryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BatteryAvgAggregateInput'] = None,
        sum: Optional['types.BatterySumAggregateInput'] = None,
        min: Optional['types.BatteryMinAggregateInput'] = None,
        max: Optional['types.BatteryMaxAggregateInput'] = None,
        having: Optional['types.BatteryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BatteryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BatteryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BatteryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BatteryGroupByOutput']:
        """Group Battery records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Battery fields to group records by
        where
            Battery filter to select records
        take
            Limit the maximum number of Battery records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BatteryGroupByOutput]
            A list of dictionaries representing the Battery record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Battery records by timestamp values
        # and count how many records are in each group
        results = await Battery.prisma().group_by(
            ['timestamp'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CameraActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Camera]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Camera.prisma().query_raw(
            'SELECT * FROM Camera WHERE id = $1',
            1874748096,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Camera
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Camera.prisma().query_first(
            'SELECT * FROM Camera WHERE turtleBotId = $1',
            916896761,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CameraCreateInput,
        include: Optional[types.CameraInclude] = None
    ) -> _PrismaModelT:
        """Create a new Camera record.

        Parameters
        ----------
        data
            Camera record data
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The created Camera record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Camera record from just the required fields
        camera = await Camera.prisma().create(
            data={
                # data to create a Camera record
                'turtleBotId': 769267518,
                'timestamp': datetime.datetime.utcnow(),
                'image': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CameraCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Camera records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Camera record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Camera.prisma().create_many(
            data=[
                {
                    # data to create a Camera record
                    'turtleBotId': 92728044,
                    'timestamp': datetime.datetime.utcnow(),
                    'image': 'deeificjd',
                },
                {
                    # data to create a Camera record
                    'turtleBotId': 1121741130,
                    'timestamp': datetime.datetime.utcnow(),
                    'image': 'bejfijgcfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Camera record.

        Parameters
        ----------
        where
            Camera filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The deleted Camera record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().delete(
            where={
                'id': 208521688,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Camera record.

        Parameters
        ----------
        where
            Camera filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The found Camera record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().find_unique(
            where={
                'id': 860811569,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Camera record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Camera filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The found Camera record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().find_unique_or_raise(
            where={
                'id': 1660932118,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
        include: Optional[types.CameraInclude] = None,
        order: Optional[Union[types.CameraOrderByInput, List[types.CameraOrderByInput]]] = None,
        distinct: Optional[List[types.CameraScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Camera records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Camera records returned
        skip
            Ignore the first N results
        where
            Camera filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Camera model
        order
            Order the returned Camera records by any field
        distinct
            Filter Camera records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Camera]
            The list of all Camera records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Camera records
        cameras = await Camera.prisma().find_many(take=10)

        # find the first 5 Camera records ordered by the timestamp field
        cameras = await Camera.prisma().find_many(
            take=5,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
        include: Optional[types.CameraInclude] = None,
        order: Optional[Union[types.CameraOrderByInput, List[types.CameraOrderByInput]]] = None,
        distinct: Optional[List[types.CameraScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Camera record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Camera filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Camera model
        order
            Order the returned Camera records by any field
        distinct
            Filter Camera records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Camera
            The first Camera record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Camera record ordered by the image field
        camera = await Camera.prisma().find_first(
            skip=1,
            order={
                'image': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
        include: Optional[types.CameraInclude] = None,
        order: Optional[Union[types.CameraOrderByInput, List[types.CameraOrderByInput]]] = None,
        distinct: Optional[List[types.CameraScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Camera record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Camera filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Camera model
        order
            Order the returned Camera records by any field
        distinct
            Filter Camera records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Camera
            The first Camera record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Camera record ordered by the id field
        camera = await Camera.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CameraUpdateInput,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Camera record.

        Parameters
        ----------
        data
            Camera record data specifying what to update
        where
            Camera filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The updated Camera record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        camera = await Camera.prisma().update(
            where={
                'id': 525761943,
            },
            data={
                # data to update the Camera record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CameraWhereUniqueInput,
        data: types.CameraUpsertInput,
        include: Optional[types.CameraInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Camera filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The created or updated Camera record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().upsert(
            where={
                'id': 736209796,
            },
            data={
                'create': {
                    'id': 736209796,
                    'turtleBotId': 1121741130,
                    'timestamp': datetime.datetime.utcnow(),
                    'image': 'bejfijgcfb',
                },
                'update': {
                    'turtleBotId': 1121741130,
                    'timestamp': datetime.datetime.utcnow(),
                    'image': 'bejfijgcfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CameraUpdateManyMutationInput,
        where: types.CameraWhereInput,
    ) -> int:
        """Update multiple Camera records

        Parameters
        ----------
        data
            Camera data to update the selected Camera records to
        where
            Filter to select the Camera records to update

        Returns
        -------
        int
            The total number of Camera records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Camera records
        total = await Camera.prisma().update_many(
            data={
                'turtleBotId': 493907821
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Camera records present in the database

        Parameters
        ----------
        select
            Select the Camera fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Camera filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CameraCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Camera.prisma().count()

        # results: prisma.types.CameraCountAggregateOutput
        results = await Camera.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CameraCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
    ) -> types.CameraCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CameraCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
    ) -> Union[int, types.CameraCountAggregateOutput]:
        """Count the number of Camera records present in the database

        Parameters
        ----------
        select
            Select the Camera fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Camera filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CameraCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Camera.prisma().count()

        # results: prisma.types.CameraCountAggregateOutput
        results = await Camera.prisma().count(
            select={
                '_all': True,
                'image': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CameraCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CameraWhereInput] = None
    ) -> int:
        """Delete multiple Camera records.

        Parameters
        ----------
        where
            Optional Camera filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Camera records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Camera records
        total = await Camera.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CameraScalarFieldKeys'],
        *,
        where: Optional['types.CameraWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CameraAvgAggregateInput'] = None,
        sum: Optional['types.CameraSumAggregateInput'] = None,
        min: Optional['types.CameraMinAggregateInput'] = None,
        max: Optional['types.CameraMaxAggregateInput'] = None,
        having: Optional['types.CameraScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CameraCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CameraScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CameraScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CameraGroupByOutput']:
        """Group Camera records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Camera fields to group records by
        where
            Camera filter to select records
        take
            Limit the maximum number of Camera records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CameraGroupByOutput]
            A list of dictionaries representing the Camera record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Camera records by id values
        # and count how many records are in each group
        results = await Camera.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LidarActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Lidar]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Lidar.prisma().query_raw(
            'SELECT * FROM Lidar WHERE id = $1',
            639686562,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Lidar
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Lidar.prisma().query_first(
            'SELECT * FROM Lidar WHERE turtleBotId = $1',
            654007347,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LidarCreateInput,
        include: Optional[types.LidarInclude] = None
    ) -> _PrismaModelT:
        """Create a new Lidar record.

        Parameters
        ----------
        data
            Lidar record data
        include
            Specifies which relations should be loaded on the returned Lidar model

        Returns
        -------
        prisma.models.Lidar
            The created Lidar record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Lidar record from just the required fields
        lidar = await Lidar.prisma().create(
            data={
                # data to create a Lidar record
                'turtleBotId': 1905261552,
                'timestamp': datetime.datetime.utcnow(),
                'scan': 'hihegjif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LidarCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Lidar records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Lidar record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Lidar.prisma().create_many(
            data=[
                {
                    # data to create a Lidar record
                    'turtleBotId': 1398328302,
                    'timestamp': datetime.datetime.utcnow(),
                    'scan': 'ifgaaagff',
                },
                {
                    # data to create a Lidar record
                    'turtleBotId': 1452336924,
                    'timestamp': datetime.datetime.utcnow(),
                    'scan': 'bfhdbjjgfd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LidarWhereUniqueInput,
        include: Optional[types.LidarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Lidar record.

        Parameters
        ----------
        where
            Lidar filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Lidar model

        Returns
        -------
        prisma.models.Lidar
            The deleted Lidar record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lidar = await Lidar.prisma().delete(
            where={
                'id': 2013903098,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LidarWhereUniqueInput,
        include: Optional[types.LidarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Lidar record.

        Parameters
        ----------
        where
            Lidar filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lidar model

        Returns
        -------
        prisma.models.Lidar
            The found Lidar record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lidar = await Lidar.prisma().find_unique(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LidarWhereUniqueInput,
        include: Optional[types.LidarInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Lidar record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Lidar filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lidar model

        Returns
        -------
        prisma.models.Lidar
            The found Lidar record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lidar = await Lidar.prisma().find_unique_or_raise(
            where={
                'id': 1800624392,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LidarWhereInput] = None,
        cursor: Optional[types.LidarWhereUniqueInput] = None,
        include: Optional[types.LidarInclude] = None,
        order: Optional[Union[types.LidarOrderByInput, List[types.LidarOrderByInput]]] = None,
        distinct: Optional[List[types.LidarScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Lidar records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Lidar records returned
        skip
            Ignore the first N results
        where
            Lidar filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lidar model
        order
            Order the returned Lidar records by any field
        distinct
            Filter Lidar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Lidar]
            The list of all Lidar records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Lidar records
        lidars = await Lidar.prisma().find_many(take=10)

        # find the first 5 Lidar records ordered by the timestamp field
        lidars = await Lidar.prisma().find_many(
            take=5,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LidarWhereInput] = None,
        cursor: Optional[types.LidarWhereUniqueInput] = None,
        include: Optional[types.LidarInclude] = None,
        order: Optional[Union[types.LidarOrderByInput, List[types.LidarOrderByInput]]] = None,
        distinct: Optional[List[types.LidarScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Lidar record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lidar filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lidar model
        order
            Order the returned Lidar records by any field
        distinct
            Filter Lidar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lidar
            The first Lidar record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lidar record ordered by the scan field
        lidar = await Lidar.prisma().find_first(
            skip=1,
            order={
                'scan': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LidarWhereInput] = None,
        cursor: Optional[types.LidarWhereUniqueInput] = None,
        include: Optional[types.LidarInclude] = None,
        order: Optional[Union[types.LidarOrderByInput, List[types.LidarOrderByInput]]] = None,
        distinct: Optional[List[types.LidarScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Lidar record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lidar filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lidar model
        order
            Order the returned Lidar records by any field
        distinct
            Filter Lidar records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lidar
            The first Lidar record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lidar record ordered by the id field
        lidar = await Lidar.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LidarUpdateInput,
        where: types.LidarWhereUniqueInput,
        include: Optional[types.LidarInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Lidar record.

        Parameters
        ----------
        data
            Lidar record data specifying what to update
        where
            Lidar filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Lidar model

        Returns
        -------
        prisma.models.Lidar
            The updated Lidar record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lidar = await Lidar.prisma().update(
            where={
                'id': 2077067425,
            },
            data={
                # data to update the Lidar record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LidarWhereUniqueInput,
        data: types.LidarUpsertInput,
        include: Optional[types.LidarInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Lidar filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Lidar model

        Returns
        -------
        prisma.models.Lidar
            The created or updated Lidar record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lidar = await Lidar.prisma().upsert(
            where={
                'id': 1672112838,
            },
            data={
                'create': {
                    'id': 1672112838,
                    'turtleBotId': 1452336924,
                    'timestamp': datetime.datetime.utcnow(),
                    'scan': 'bfhdbjjgfd',
                },
                'update': {
                    'turtleBotId': 1452336924,
                    'timestamp': datetime.datetime.utcnow(),
                    'scan': 'bfhdbjjgfd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LidarUpdateManyMutationInput,
        where: types.LidarWhereInput,
    ) -> int:
        """Update multiple Lidar records

        Parameters
        ----------
        data
            Lidar data to update the selected Lidar records to
        where
            Filter to select the Lidar records to update

        Returns
        -------
        int
            The total number of Lidar records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Lidar records
        total = await Lidar.prisma().update_many(
            data={
                'turtleBotId': 926677639
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LidarWhereInput] = None,
        cursor: Optional[types.LidarWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Lidar records present in the database

        Parameters
        ----------
        select
            Select the Lidar fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lidar filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LidarCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lidar.prisma().count()

        # results: prisma.types.LidarCountAggregateOutput
        results = await Lidar.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LidarCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LidarWhereInput] = None,
        cursor: Optional[types.LidarWhereUniqueInput] = None,
    ) -> types.LidarCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LidarCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LidarWhereInput] = None,
        cursor: Optional[types.LidarWhereUniqueInput] = None,
    ) -> Union[int, types.LidarCountAggregateOutput]:
        """Count the number of Lidar records present in the database

        Parameters
        ----------
        select
            Select the Lidar fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lidar filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LidarCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lidar.prisma().count()

        # results: prisma.types.LidarCountAggregateOutput
        results = await Lidar.prisma().count(
            select={
                '_all': True,
                'scan': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LidarCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LidarWhereInput] = None
    ) -> int:
        """Delete multiple Lidar records.

        Parameters
        ----------
        where
            Optional Lidar filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Lidar records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Lidar records
        total = await Lidar.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LidarScalarFieldKeys'],
        *,
        where: Optional['types.LidarWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LidarAvgAggregateInput'] = None,
        sum: Optional['types.LidarSumAggregateInput'] = None,
        min: Optional['types.LidarMinAggregateInput'] = None,
        max: Optional['types.LidarMaxAggregateInput'] = None,
        having: Optional['types.LidarScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LidarCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LidarScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LidarScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LidarGroupByOutput']:
        """Group Lidar records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Lidar fields to group records by
        where
            Lidar filter to select records
        take
            Limit the maximum number of Lidar records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LidarGroupByOutput]
            A list of dictionaries representing the Lidar record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Lidar records by id values
        # and count how many records are in each group
        results = await Lidar.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WaypointActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Waypoint]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Waypoint.prisma().query_raw(
            'SELECT * FROM Waypoint WHERE id = $1',
            1447624116,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Waypoint
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Waypoint.prisma().query_first(
            'SELECT * FROM Waypoint WHERE turtleBotId = $1',
            1738083805,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WaypointCreateInput,
        include: Optional[types.WaypointInclude] = None
    ) -> _PrismaModelT:
        """Create a new Waypoint record.

        Parameters
        ----------
        data
            Waypoint record data
        include
            Specifies which relations should be loaded on the returned Waypoint model

        Returns
        -------
        prisma.models.Waypoint
            The created Waypoint record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Waypoint record from just the required fields
        waypoint = await Waypoint.prisma().create(
            data={
                # data to create a Waypoint record
                'turtleBotId': 340946258,
                'timestamp': datetime.datetime.utcnow(),
                'x': 601077795.29060,
                'y': 1855826649.161100,
                'theta': 446673791.30056,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WaypointCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Waypoint records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Waypoint record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Waypoint.prisma().create_many(
            data=[
                {
                    # data to create a Waypoint record
                    'turtleBotId': 632626069,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 1724011690.47015,
                    'y': 1209209912.153674,
                    'theta': 424218998.212563,
                },
                {
                    # data to create a Waypoint record
                    'turtleBotId': 536951780,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 924723277.162193,
                    'y': 1848832019.192152,
                    'theta': 2100427849.84914,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WaypointWhereUniqueInput,
        include: Optional[types.WaypointInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Waypoint record.

        Parameters
        ----------
        where
            Waypoint filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Waypoint model

        Returns
        -------
        prisma.models.Waypoint
            The deleted Waypoint record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        waypoint = await Waypoint.prisma().delete(
            where={
                'id': 928152175,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WaypointWhereUniqueInput,
        include: Optional[types.WaypointInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Waypoint record.

        Parameters
        ----------
        where
            Waypoint filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Waypoint model

        Returns
        -------
        prisma.models.Waypoint
            The found Waypoint record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        waypoint = await Waypoint.prisma().find_unique(
            where={
                'id': 273032060,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WaypointWhereUniqueInput,
        include: Optional[types.WaypointInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Waypoint record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Waypoint filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Waypoint model

        Returns
        -------
        prisma.models.Waypoint
            The found Waypoint record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        waypoint = await Waypoint.prisma().find_unique_or_raise(
            where={
                'id': 982848517,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WaypointWhereInput] = None,
        cursor: Optional[types.WaypointWhereUniqueInput] = None,
        include: Optional[types.WaypointInclude] = None,
        order: Optional[Union[types.WaypointOrderByInput, List[types.WaypointOrderByInput]]] = None,
        distinct: Optional[List[types.WaypointScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Waypoint records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Waypoint records returned
        skip
            Ignore the first N results
        where
            Waypoint filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Waypoint model
        order
            Order the returned Waypoint records by any field
        distinct
            Filter Waypoint records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Waypoint]
            The list of all Waypoint records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Waypoint records
        waypoints = await Waypoint.prisma().find_many(take=10)

        # find the first 5 Waypoint records ordered by the timestamp field
        waypoints = await Waypoint.prisma().find_many(
            take=5,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WaypointWhereInput] = None,
        cursor: Optional[types.WaypointWhereUniqueInput] = None,
        include: Optional[types.WaypointInclude] = None,
        order: Optional[Union[types.WaypointOrderByInput, List[types.WaypointOrderByInput]]] = None,
        distinct: Optional[List[types.WaypointScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Waypoint record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Waypoint filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Waypoint model
        order
            Order the returned Waypoint records by any field
        distinct
            Filter Waypoint records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Waypoint
            The first Waypoint record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Waypoint record ordered by the x field
        waypoint = await Waypoint.prisma().find_first(
            skip=1,
            order={
                'x': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WaypointWhereInput] = None,
        cursor: Optional[types.WaypointWhereUniqueInput] = None,
        include: Optional[types.WaypointInclude] = None,
        order: Optional[Union[types.WaypointOrderByInput, List[types.WaypointOrderByInput]]] = None,
        distinct: Optional[List[types.WaypointScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Waypoint record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Waypoint filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Waypoint model
        order
            Order the returned Waypoint records by any field
        distinct
            Filter Waypoint records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Waypoint
            The first Waypoint record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Waypoint record ordered by the y field
        waypoint = await Waypoint.prisma().find_first_or_raise(
            skip=1,
            order={
                'y': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WaypointUpdateInput,
        where: types.WaypointWhereUniqueInput,
        include: Optional[types.WaypointInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Waypoint record.

        Parameters
        ----------
        data
            Waypoint record data specifying what to update
        where
            Waypoint filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Waypoint model

        Returns
        -------
        prisma.models.Waypoint
            The updated Waypoint record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        waypoint = await Waypoint.prisma().update(
            where={
                'id': 510737498,
            },
            data={
                # data to update the Waypoint record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WaypointWhereUniqueInput,
        data: types.WaypointUpsertInput,
        include: Optional[types.WaypointInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Waypoint filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Waypoint model

        Returns
        -------
        prisma.models.Waypoint
            The created or updated Waypoint record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        waypoint = await Waypoint.prisma().upsert(
            where={
                'id': 2117488267,
            },
            data={
                'create': {
                    'id': 2117488267,
                    'turtleBotId': 536951780,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 924723277.162193,
                    'y': 1848832019.192152,
                    'theta': 2100427849.84914,
                },
                'update': {
                    'turtleBotId': 536951780,
                    'timestamp': datetime.datetime.utcnow(),
                    'x': 924723277.162193,
                    'y': 1848832019.192152,
                    'theta': 2100427849.84914,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WaypointUpdateManyMutationInput,
        where: types.WaypointWhereInput,
    ) -> int:
        """Update multiple Waypoint records

        Parameters
        ----------
        data
            Waypoint data to update the selected Waypoint records to
        where
            Filter to select the Waypoint records to update

        Returns
        -------
        int
            The total number of Waypoint records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Waypoint records
        total = await Waypoint.prisma().update_many(
            data={
                'theta': 1401944936.129760
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WaypointWhereInput] = None,
        cursor: Optional[types.WaypointWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Waypoint records present in the database

        Parameters
        ----------
        select
            Select the Waypoint fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Waypoint filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WaypointCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Waypoint.prisma().count()

        # results: prisma.types.WaypointCountAggregateOutput
        results = await Waypoint.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WaypointCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WaypointWhereInput] = None,
        cursor: Optional[types.WaypointWhereUniqueInput] = None,
    ) -> types.WaypointCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WaypointCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WaypointWhereInput] = None,
        cursor: Optional[types.WaypointWhereUniqueInput] = None,
    ) -> Union[int, types.WaypointCountAggregateOutput]:
        """Count the number of Waypoint records present in the database

        Parameters
        ----------
        select
            Select the Waypoint fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Waypoint filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WaypointCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Waypoint.prisma().count()

        # results: prisma.types.WaypointCountAggregateOutput
        results = await Waypoint.prisma().count(
            select={
                '_all': True,
                'turtleBotId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WaypointCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WaypointWhereInput] = None
    ) -> int:
        """Delete multiple Waypoint records.

        Parameters
        ----------
        where
            Optional Waypoint filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Waypoint records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Waypoint records
        total = await Waypoint.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WaypointScalarFieldKeys'],
        *,
        where: Optional['types.WaypointWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WaypointAvgAggregateInput'] = None,
        sum: Optional['types.WaypointSumAggregateInput'] = None,
        min: Optional['types.WaypointMinAggregateInput'] = None,
        max: Optional['types.WaypointMaxAggregateInput'] = None,
        having: Optional['types.WaypointScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WaypointCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WaypointScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WaypointScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WaypointGroupByOutput']:
        """Group Waypoint records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Waypoint fields to group records by
        where
            Waypoint filter to select records
        take
            Limit the maximum number of Waypoint records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WaypointGroupByOutput]
            A list of dictionaries representing the Waypoint record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Waypoint records by timestamp values
        # and count how many records are in each group
        results = await Waypoint.prisma().group_by(
            ['timestamp'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MapActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Map]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Map.prisma().query_raw(
            'SELECT * FROM Map WHERE id = $1',
            519488550,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Map
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Map.prisma().query_first(
            'SELECT * FROM Map WHERE turtleBotId = $1',
            976832615,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MapCreateInput,
        include: Optional[types.MapInclude] = None
    ) -> _PrismaModelT:
        """Create a new Map record.

        Parameters
        ----------
        data
            Map record data
        include
            Specifies which relations should be loaded on the returned Map model

        Returns
        -------
        prisma.models.Map
            The created Map record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Map record from just the required fields
        map = await Map.prisma().create(
            data={
                # data to create a Map record
                'turtleBotId': 1696425492,
                'timestamp': datetime.datetime.utcnow(),
                'data': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MapCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Map records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Map record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Map.prisma().create_many(
            data=[
                {
                    # data to create a Map record
                    'turtleBotId': 1023081650,
                    'timestamp': datetime.datetime.utcnow(),
                    'data': 'dchgibach',
                },
                {
                    # data to create a Map record
                    'turtleBotId': 527748992,
                    'timestamp': datetime.datetime.utcnow(),
                    'data': 'cacjdfhejh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MapWhereUniqueInput,
        include: Optional[types.MapInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Map record.

        Parameters
        ----------
        where
            Map filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Map model

        Returns
        -------
        prisma.models.Map
            The deleted Map record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        map = await Map.prisma().delete(
            where={
                'id': 1318597118,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MapWhereUniqueInput,
        include: Optional[types.MapInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Map record.

        Parameters
        ----------
        where
            Map filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Map model

        Returns
        -------
        prisma.models.Map
            The found Map record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        map = await Map.prisma().find_unique(
            where={
                'id': 2122112351,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MapWhereUniqueInput,
        include: Optional[types.MapInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Map record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Map filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Map model

        Returns
        -------
        prisma.models.Map
            The found Map record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        map = await Map.prisma().find_unique_or_raise(
            where={
                'id': 1024943020,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MapWhereInput] = None,
        cursor: Optional[types.MapWhereUniqueInput] = None,
        include: Optional[types.MapInclude] = None,
        order: Optional[Union[types.MapOrderByInput, List[types.MapOrderByInput]]] = None,
        distinct: Optional[List[types.MapScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Map records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Map records returned
        skip
            Ignore the first N results
        where
            Map filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Map model
        order
            Order the returned Map records by any field
        distinct
            Filter Map records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Map]
            The list of all Map records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Map records
        maps = await Map.prisma().find_many(take=10)

        # find the first 5 Map records ordered by the timestamp field
        maps = await Map.prisma().find_many(
            take=5,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MapWhereInput] = None,
        cursor: Optional[types.MapWhereUniqueInput] = None,
        include: Optional[types.MapInclude] = None,
        order: Optional[Union[types.MapOrderByInput, List[types.MapOrderByInput]]] = None,
        distinct: Optional[List[types.MapScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Map record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Map filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Map model
        order
            Order the returned Map records by any field
        distinct
            Filter Map records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Map
            The first Map record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Map record ordered by the data field
        map = await Map.prisma().find_first(
            skip=1,
            order={
                'data': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MapWhereInput] = None,
        cursor: Optional[types.MapWhereUniqueInput] = None,
        include: Optional[types.MapInclude] = None,
        order: Optional[Union[types.MapOrderByInput, List[types.MapOrderByInput]]] = None,
        distinct: Optional[List[types.MapScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Map record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Map filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Map model
        order
            Order the returned Map records by any field
        distinct
            Filter Map records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Map
            The first Map record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Map record ordered by the id field
        map = await Map.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MapUpdateInput,
        where: types.MapWhereUniqueInput,
        include: Optional[types.MapInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Map record.

        Parameters
        ----------
        data
            Map record data specifying what to update
        where
            Map filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Map model

        Returns
        -------
        prisma.models.Map
            The updated Map record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        map = await Map.prisma().update(
            where={
                'id': 1717307509,
            },
            data={
                # data to update the Map record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MapWhereUniqueInput,
        data: types.MapUpsertInput,
        include: Optional[types.MapInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Map filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Map model

        Returns
        -------
        prisma.models.Map
            The created or updated Map record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        map = await Map.prisma().upsert(
            where={
                'id': 1598124042,
            },
            data={
                'create': {
                    'id': 1598124042,
                    'turtleBotId': 527748992,
                    'timestamp': datetime.datetime.utcnow(),
                    'data': 'cacjdfhejh',
                },
                'update': {
                    'turtleBotId': 527748992,
                    'timestamp': datetime.datetime.utcnow(),
                    'data': 'cacjdfhejh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MapUpdateManyMutationInput,
        where: types.MapWhereInput,
    ) -> int:
        """Update multiple Map records

        Parameters
        ----------
        data
            Map data to update the selected Map records to
        where
            Filter to select the Map records to update

        Returns
        -------
        int
            The total number of Map records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Map records
        total = await Map.prisma().update_many(
            data={
                'turtleBotId': 817623163
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MapWhereInput] = None,
        cursor: Optional[types.MapWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Map records present in the database

        Parameters
        ----------
        select
            Select the Map fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Map filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MapCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Map.prisma().count()

        # results: prisma.types.MapCountAggregateOutput
        results = await Map.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MapCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MapWhereInput] = None,
        cursor: Optional[types.MapWhereUniqueInput] = None,
    ) -> types.MapCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MapCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MapWhereInput] = None,
        cursor: Optional[types.MapWhereUniqueInput] = None,
    ) -> Union[int, types.MapCountAggregateOutput]:
        """Count the number of Map records present in the database

        Parameters
        ----------
        select
            Select the Map fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Map filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MapCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Map.prisma().count()

        # results: prisma.types.MapCountAggregateOutput
        results = await Map.prisma().count(
            select={
                '_all': True,
                'data': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MapCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MapWhereInput] = None
    ) -> int:
        """Delete multiple Map records.

        Parameters
        ----------
        where
            Optional Map filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Map records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Map records
        total = await Map.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MapScalarFieldKeys'],
        *,
        where: Optional['types.MapWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MapAvgAggregateInput'] = None,
        sum: Optional['types.MapSumAggregateInput'] = None,
        min: Optional['types.MapMinAggregateInput'] = None,
        max: Optional['types.MapMaxAggregateInput'] = None,
        having: Optional['types.MapScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MapCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MapScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MapScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MapGroupByOutput']:
        """Group Map records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Map fields to group records by
        where
            Map filter to select records
        take
            Limit the maximum number of Map records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MapGroupByOutput]
            A list of dictionaries representing the Map record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Map records by id values
        # and count how many records are in each group
        results = await Map.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models