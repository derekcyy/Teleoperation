# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# TurtleBot types

class TurtleBotOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the TurtleBot create method"""
    id: _int
    createdAt: datetime.datetime
    telemetry: 'TelemetryCreateManyNestedWithoutRelationsInput'
    battery: 'BatteryCreateManyNestedWithoutRelationsInput'
    camera: 'CameraCreateManyNestedWithoutRelationsInput'
    lidar: 'LidarCreateManyNestedWithoutRelationsInput'
    waypoint: 'WaypointCreateManyNestedWithoutRelationsInput'
    map: 'MapCreateManyNestedWithoutRelationsInput'


class TurtleBotCreateInput(TurtleBotOptionalCreateInput):
    """Required arguments to the TurtleBot create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TurtleBotOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the TurtleBot create method, without relations"""
    id: _int
    createdAt: datetime.datetime


class TurtleBotCreateWithoutRelationsInput(TurtleBotOptionalCreateWithoutRelationsInput):
    """Required arguments to the TurtleBot create method, without relations"""
    name: _str


class TurtleBotCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TurtleBotCreateWithoutRelationsInput'
    connect: 'TurtleBotWhereUniqueInput'


class TurtleBotCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TurtleBotCreateWithoutRelationsInput', List['TurtleBotCreateWithoutRelationsInput']]
    connect: Union['TurtleBotWhereUniqueInput', List['TurtleBotWhereUniqueInput']]


_TurtleBotWhereUnique_id_Input = TypedDict(
    '_TurtleBotWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_TurtleBotWhereUnique_name_Input = TypedDict(
    '_TurtleBotWhereUnique_name_Input',
    {
        'name': '_str',
    },
    total=True
)

TurtleBotWhereUniqueInput = Union[
    '_TurtleBotWhereUnique_id_Input',
    '_TurtleBotWhereUnique_name_Input',
]


class TurtleBotUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    createdAt: datetime.datetime
    telemetry: 'TelemetryUpdateManyWithoutRelationsInput'
    battery: 'BatteryUpdateManyWithoutRelationsInput'
    camera: 'CameraUpdateManyWithoutRelationsInput'
    lidar: 'LidarUpdateManyWithoutRelationsInput'
    waypoint: 'WaypointUpdateManyWithoutRelationsInput'
    map: 'MapUpdateManyWithoutRelationsInput'


class TurtleBotUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    createdAt: datetime.datetime


class TurtleBotUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TurtleBotCreateWithoutRelationsInput']
    connect: List['TurtleBotWhereUniqueInput']
    set: List['TurtleBotWhereUniqueInput']
    disconnect: List['TurtleBotWhereUniqueInput']
    delete: List['TurtleBotWhereUniqueInput']

    # TODO
    # update: List['TurtleBotUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TurtleBotUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TurtleBotScalarWhereInput']
    # upsert: List['TurtleBotUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['TurtleBotCreateOrConnectWithoutRelationsInput']


class TurtleBotUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TurtleBotCreateWithoutRelationsInput'
    connect: 'TurtleBotWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TurtleBotUpdateInput'
    # upsert: 'TurtleBotUpsertWithoutRelationsInput'
    # connectOrCreate: 'TurtleBotCreateOrConnectWithoutRelationsInput'


class TurtleBotUpsertInput(TypedDict):
    create: 'TurtleBotCreateInput'
    update: 'TurtleBotUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_TurtleBot_id_OrderByInput = TypedDict(
    '_TurtleBot_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_TurtleBot_name_OrderByInput = TypedDict(
    '_TurtleBot_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_TurtleBot_createdAt_OrderByInput = TypedDict(
    '_TurtleBot_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

TurtleBotOrderByInput = Union[
    '_TurtleBot_id_OrderByInput',
    '_TurtleBot_name_OrderByInput',
    '_TurtleBot_createdAt_OrderByInput',
]



# recursive TurtleBot types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TurtleBotRelationFilter = TypedDict(
    'TurtleBotRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TurtleBotListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TurtleBotInclude(TypedDict, total=False):
    """TurtleBot relational arguments"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTurtleBot']
    battery: Union[bool, 'FindManyBatteryArgsFromTurtleBot']
    camera: Union[bool, 'FindManyCameraArgsFromTurtleBot']
    lidar: Union[bool, 'FindManyLidarArgsFromTurtleBot']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTurtleBot']
    map: Union[bool, 'FindManyMapArgsFromTurtleBot']


    

class TurtleBotIncludeFromTurtleBot(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTurtleBotRecursive1']
    battery: Union[bool, 'FindManyBatteryArgsFromTurtleBotRecursive1']
    camera: Union[bool, 'FindManyCameraArgsFromTurtleBotRecursive1']
    lidar: Union[bool, 'FindManyLidarArgsFromTurtleBotRecursive1']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTurtleBotRecursive1']
    map: Union[bool, 'FindManyMapArgsFromTurtleBotRecursive1']


class TurtleBotIncludeFromTurtleBotRecursive1(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTurtleBotRecursive2']
    battery: Union[bool, 'FindManyBatteryArgsFromTurtleBotRecursive2']
    camera: Union[bool, 'FindManyCameraArgsFromTurtleBotRecursive2']
    lidar: Union[bool, 'FindManyLidarArgsFromTurtleBotRecursive2']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTurtleBotRecursive2']
    map: Union[bool, 'FindManyMapArgsFromTurtleBotRecursive2']


class TurtleBotIncludeFromTurtleBotRecursive2(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTurtleBotRecursive3']
    battery: Union[bool, 'FindManyBatteryArgsFromTurtleBotRecursive3']
    camera: Union[bool, 'FindManyCameraArgsFromTurtleBotRecursive3']
    lidar: Union[bool, 'FindManyLidarArgsFromTurtleBotRecursive3']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTurtleBotRecursive3']
    map: Union[bool, 'FindManyMapArgsFromTurtleBotRecursive3']


class TurtleBotIncludeFromTurtleBotRecursive3(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTurtleBotRecursive4']
    battery: Union[bool, 'FindManyBatteryArgsFromTurtleBotRecursive4']
    camera: Union[bool, 'FindManyCameraArgsFromTurtleBotRecursive4']
    lidar: Union[bool, 'FindManyLidarArgsFromTurtleBotRecursive4']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTurtleBotRecursive4']
    map: Union[bool, 'FindManyMapArgsFromTurtleBotRecursive4']


class TurtleBotIncludeFromTurtleBotRecursive4(TypedDict, total=False):
    """Relational arguments for TurtleBot"""

    

class TurtleBotArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class TurtleBotArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class TurtleBotArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class TurtleBotArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class TurtleBotArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    
    

class FindManyTurtleBotArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class FindManyTurtleBotArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class FindManyTurtleBotArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class FindManyTurtleBotArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class FindManyTurtleBotArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    
    

class TelemetryIncludeFromTurtleBot(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive1']


class TelemetryIncludeFromTurtleBotRecursive1(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive2']


class TelemetryIncludeFromTurtleBotRecursive2(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive3']


class TelemetryIncludeFromTurtleBotRecursive3(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive4']


class TelemetryIncludeFromTurtleBotRecursive4(TypedDict, total=False):
    """Relational arguments for TurtleBot"""

    

class TelemetryArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class TelemetryArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class TelemetryArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class TelemetryArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class TelemetryArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    
    

class FindManyTelemetryArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class FindManyTelemetryArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class FindManyTelemetryArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class FindManyTelemetryArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class FindManyTelemetryArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    
    

class BatteryIncludeFromTurtleBot(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive1']


class BatteryIncludeFromTurtleBotRecursive1(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive2']


class BatteryIncludeFromTurtleBotRecursive2(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive3']


class BatteryIncludeFromTurtleBotRecursive3(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive4']


class BatteryIncludeFromTurtleBotRecursive4(TypedDict, total=False):
    """Relational arguments for TurtleBot"""

    

class BatteryArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'BatteryIncludeFromBatteryRecursive1'


class BatteryArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'BatteryIncludeFromBatteryRecursive2'


class BatteryArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'BatteryIncludeFromBatteryRecursive3'


class BatteryArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'BatteryIncludeFromBatteryRecursive4'


class BatteryArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    
    

class FindManyBatteryArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive1'


class FindManyBatteryArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive2'


class FindManyBatteryArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive3'


class FindManyBatteryArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive4'


class FindManyBatteryArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    
    

class CameraIncludeFromTurtleBot(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive1']


class CameraIncludeFromTurtleBotRecursive1(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive2']


class CameraIncludeFromTurtleBotRecursive2(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive3']


class CameraIncludeFromTurtleBotRecursive3(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive4']


class CameraIncludeFromTurtleBotRecursive4(TypedDict, total=False):
    """Relational arguments for TurtleBot"""

    

class CameraArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'CameraIncludeFromCameraRecursive1'


class CameraArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'CameraIncludeFromCameraRecursive2'


class CameraArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'CameraIncludeFromCameraRecursive3'


class CameraArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'CameraIncludeFromCameraRecursive4'


class CameraArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    
    

class FindManyCameraArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive1'


class FindManyCameraArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive2'


class FindManyCameraArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive3'


class FindManyCameraArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive4'


class FindManyCameraArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    
    

class LidarIncludeFromTurtleBot(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive1']


class LidarIncludeFromTurtleBotRecursive1(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive2']


class LidarIncludeFromTurtleBotRecursive2(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive3']


class LidarIncludeFromTurtleBotRecursive3(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive4']


class LidarIncludeFromTurtleBotRecursive4(TypedDict, total=False):
    """Relational arguments for TurtleBot"""

    

class LidarArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'LidarIncludeFromLidarRecursive1'


class LidarArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'LidarIncludeFromLidarRecursive2'


class LidarArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'LidarIncludeFromLidarRecursive3'


class LidarArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'LidarIncludeFromLidarRecursive4'


class LidarArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    
    

class FindManyLidarArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive1'


class FindManyLidarArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive2'


class FindManyLidarArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive3'


class FindManyLidarArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive4'


class FindManyLidarArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    
    

class WaypointIncludeFromTurtleBot(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive1']


class WaypointIncludeFromTurtleBotRecursive1(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive2']


class WaypointIncludeFromTurtleBotRecursive2(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive3']


class WaypointIncludeFromTurtleBotRecursive3(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive4']


class WaypointIncludeFromTurtleBotRecursive4(TypedDict, total=False):
    """Relational arguments for TurtleBot"""

    

class WaypointArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'WaypointIncludeFromWaypointRecursive1'


class WaypointArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'WaypointIncludeFromWaypointRecursive2'


class WaypointArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'WaypointIncludeFromWaypointRecursive3'


class WaypointArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'WaypointIncludeFromWaypointRecursive4'


class WaypointArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    
    

class FindManyWaypointArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive1'


class FindManyWaypointArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive2'


class FindManyWaypointArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive3'


class FindManyWaypointArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive4'


class FindManyWaypointArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    
    

class MapIncludeFromTurtleBot(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive1']


class MapIncludeFromTurtleBotRecursive1(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive2']


class MapIncludeFromTurtleBotRecursive2(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive3']


class MapIncludeFromTurtleBotRecursive3(TypedDict, total=False):
    """Relational arguments for TurtleBot"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTurtleBotRecursive4']


class MapIncludeFromTurtleBotRecursive4(TypedDict, total=False):
    """Relational arguments for TurtleBot"""

    

class MapArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'MapIncludeFromMapRecursive1'


class MapArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'MapIncludeFromMapRecursive2'


class MapArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'MapIncludeFromMapRecursive3'


class MapArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    include: 'MapIncludeFromMapRecursive4'


class MapArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    
    

class FindManyMapArgsFromTurtleBot(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive1'


class FindManyMapArgsFromTurtleBotRecursive1(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive2'


class FindManyMapArgsFromTurtleBotRecursive2(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive3'


class FindManyMapArgsFromTurtleBotRecursive3(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive4'


class FindManyMapArgsFromTurtleBotRecursive4(TypedDict, total=False):
    """Arguments for TurtleBot"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    


FindManyTurtleBotArgs = FindManyTurtleBotArgsFromTurtleBot
FindFirstTurtleBotArgs = FindManyTurtleBotArgsFromTurtleBot


    

class TurtleBotWhereInput(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    telemetry: 'TelemetryListRelationFilter'
    battery: 'BatteryListRelationFilter'
    camera: 'CameraListRelationFilter'
    lidar: 'LidarListRelationFilter'
    waypoint: 'WaypointListRelationFilter'
    map: 'MapListRelationFilter'

    # should be noted that AND and NOT should be Union['TurtleBotWhereInputRecursive1', List['TurtleBotWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TurtleBotWhereInputRecursive1']
    OR: List['TurtleBotWhereInputRecursive1']
    NOT: List['TurtleBotWhereInputRecursive1']


class TurtleBotWhereInputRecursive1(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    telemetry: 'TelemetryListRelationFilter'
    battery: 'BatteryListRelationFilter'
    camera: 'CameraListRelationFilter'
    lidar: 'LidarListRelationFilter'
    waypoint: 'WaypointListRelationFilter'
    map: 'MapListRelationFilter'

    # should be noted that AND and NOT should be Union['TurtleBotWhereInputRecursive2', List['TurtleBotWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TurtleBotWhereInputRecursive2']
    OR: List['TurtleBotWhereInputRecursive2']
    NOT: List['TurtleBotWhereInputRecursive2']


class TurtleBotWhereInputRecursive2(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    telemetry: 'TelemetryListRelationFilter'
    battery: 'BatteryListRelationFilter'
    camera: 'CameraListRelationFilter'
    lidar: 'LidarListRelationFilter'
    waypoint: 'WaypointListRelationFilter'
    map: 'MapListRelationFilter'

    # should be noted that AND and NOT should be Union['TurtleBotWhereInputRecursive3', List['TurtleBotWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TurtleBotWhereInputRecursive3']
    OR: List['TurtleBotWhereInputRecursive3']
    NOT: List['TurtleBotWhereInputRecursive3']


class TurtleBotWhereInputRecursive3(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    telemetry: 'TelemetryListRelationFilter'
    battery: 'BatteryListRelationFilter'
    camera: 'CameraListRelationFilter'
    lidar: 'LidarListRelationFilter'
    waypoint: 'WaypointListRelationFilter'
    map: 'MapListRelationFilter'

    # should be noted that AND and NOT should be Union['TurtleBotWhereInputRecursive4', List['TurtleBotWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TurtleBotWhereInputRecursive4']
    OR: List['TurtleBotWhereInputRecursive4']
    NOT: List['TurtleBotWhereInputRecursive4']


class TurtleBotWhereInputRecursive4(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    telemetry: 'TelemetryListRelationFilter'
    battery: 'BatteryListRelationFilter'
    camera: 'CameraListRelationFilter'
    lidar: 'LidarListRelationFilter'
    waypoint: 'WaypointListRelationFilter'
    map: 'MapListRelationFilter'



# aggregate TurtleBot types


    

class TurtleBotScalarWhereWithAggregatesInput(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TurtleBotScalarWhereWithAggregatesInputRecursive1']
    OR: List['TurtleBotScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TurtleBotScalarWhereWithAggregatesInputRecursive1']


class TurtleBotScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TurtleBotScalarWhereWithAggregatesInputRecursive2']
    OR: List['TurtleBotScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TurtleBotScalarWhereWithAggregatesInputRecursive2']


class TurtleBotScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TurtleBotScalarWhereWithAggregatesInputRecursive3']
    OR: List['TurtleBotScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TurtleBotScalarWhereWithAggregatesInputRecursive3']


class TurtleBotScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TurtleBotScalarWhereWithAggregatesInputRecursive4']
    OR: List['TurtleBotScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TurtleBotScalarWhereWithAggregatesInputRecursive4']


class TurtleBotScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """TurtleBot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class TurtleBotGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    createdAt: datetime.datetime
    _sum: 'TurtleBotSumAggregateOutput'
    _avg: 'TurtleBotAvgAggregateOutput'
    _min: 'TurtleBotMinAggregateOutput'
    _max: 'TurtleBotMaxAggregateOutput'
    _count: 'TurtleBotCountAggregateOutput'


class TurtleBotAvgAggregateOutput(TypedDict, total=False):
    """TurtleBot output for aggregating averages"""
    id: float


class TurtleBotSumAggregateOutput(TypedDict, total=False):
    """TurtleBot output for aggregating sums"""
    id: _int


class TurtleBotScalarAggregateOutput(TypedDict, total=False):
    """TurtleBot output including scalar fields"""
    id: _int
    name: _str
    createdAt: datetime.datetime


TurtleBotMinAggregateOutput = TurtleBotScalarAggregateOutput
TurtleBotMaxAggregateOutput = TurtleBotScalarAggregateOutput


class TurtleBotMaxAggregateInput(TypedDict, total=False):
    """TurtleBot input for aggregating by max"""
    id: bool
    name: bool
    createdAt: bool


class TurtleBotMinAggregateInput(TypedDict, total=False):
    """TurtleBot input for aggregating by min"""
    id: bool
    name: bool
    createdAt: bool


class TurtleBotNumberAggregateInput(TypedDict, total=False):
    """TurtleBot input for aggregating numbers"""
    id: bool


TurtleBotAvgAggregateInput = TurtleBotNumberAggregateInput
TurtleBotSumAggregateInput = TurtleBotNumberAggregateInput


TurtleBotCountAggregateInput = TypedDict(
    'TurtleBotCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

TurtleBotCountAggregateOutput = TypedDict(
    'TurtleBotCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


TurtleBotKeys = Literal[
    'id',
    'name',
    'createdAt',
    'telemetry',
    'battery',
    'camera',
    'lidar',
    'waypoint',
    'map',
]
TurtleBotScalarFieldKeys = Literal[
    'id',
    'name',
    'createdAt',
]
TurtleBotScalarFieldKeysT = TypeVar('TurtleBotScalarFieldKeysT', bound=TurtleBotScalarFieldKeys)

TurtleBotRelationalFieldKeys = Literal[
        'telemetry',
        'battery',
        'camera',
        'lidar',
        'waypoint',
        'map',
    ]

# Telemetry types

class TelemetryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Telemetry create method"""
    id: _int
    turtleBotId: _int
    turtleBot: 'TurtleBotCreateNestedWithoutRelationsInput'


class TelemetryCreateInput(TelemetryOptionalCreateInput):
    """Required arguments to the Telemetry create method"""
    timestamp: datetime.datetime
    x: _float
    y: _float
    heading: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TelemetryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Telemetry create method, without relations"""
    id: _int
    turtleBotId: _int


class TelemetryCreateWithoutRelationsInput(TelemetryOptionalCreateWithoutRelationsInput):
    """Required arguments to the Telemetry create method, without relations"""
    timestamp: datetime.datetime
    x: _float
    y: _float
    heading: _float


class TelemetryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TelemetryCreateWithoutRelationsInput'
    connect: 'TelemetryWhereUniqueInput'


class TelemetryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TelemetryCreateWithoutRelationsInput', List['TelemetryCreateWithoutRelationsInput']]
    connect: Union['TelemetryWhereUniqueInput', List['TelemetryWhereUniqueInput']]


_TelemetryWhereUnique_id_Input = TypedDict(
    '_TelemetryWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

TelemetryWhereUniqueInput = _TelemetryWhereUnique_id_Input


class TelemetryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    x: Union[AtomicFloatInput, _float]
    y: Union[AtomicFloatInput, _float]
    heading: Union[AtomicFloatInput, _float]
    turtleBot: 'TurtleBotUpdateOneWithoutRelationsInput'


class TelemetryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    x: Union[AtomicFloatInput, _float]
    y: Union[AtomicFloatInput, _float]
    heading: Union[AtomicFloatInput, _float]


class TelemetryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TelemetryCreateWithoutRelationsInput']
    connect: List['TelemetryWhereUniqueInput']
    set: List['TelemetryWhereUniqueInput']
    disconnect: List['TelemetryWhereUniqueInput']
    delete: List['TelemetryWhereUniqueInput']

    # TODO
    # update: List['TelemetryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TelemetryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TelemetryScalarWhereInput']
    # upsert: List['TelemetryUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['TelemetryCreateOrConnectWithoutRelationsInput']


class TelemetryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TelemetryCreateWithoutRelationsInput'
    connect: 'TelemetryWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TelemetryUpdateInput'
    # upsert: 'TelemetryUpsertWithoutRelationsInput'
    # connectOrCreate: 'TelemetryCreateOrConnectWithoutRelationsInput'


class TelemetryUpsertInput(TypedDict):
    create: 'TelemetryCreateInput'
    update: 'TelemetryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Telemetry_id_OrderByInput = TypedDict(
    '_Telemetry_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Telemetry_turtleBotId_OrderByInput = TypedDict(
    '_Telemetry_turtleBotId_OrderByInput',
    {
        'turtleBotId': 'SortOrder',
    },
    total=True
)

_Telemetry_timestamp_OrderByInput = TypedDict(
    '_Telemetry_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_Telemetry_x_OrderByInput = TypedDict(
    '_Telemetry_x_OrderByInput',
    {
        'x': 'SortOrder',
    },
    total=True
)

_Telemetry_y_OrderByInput = TypedDict(
    '_Telemetry_y_OrderByInput',
    {
        'y': 'SortOrder',
    },
    total=True
)

_Telemetry_heading_OrderByInput = TypedDict(
    '_Telemetry_heading_OrderByInput',
    {
        'heading': 'SortOrder',
    },
    total=True
)

TelemetryOrderByInput = Union[
    '_Telemetry_id_OrderByInput',
    '_Telemetry_turtleBotId_OrderByInput',
    '_Telemetry_timestamp_OrderByInput',
    '_Telemetry_x_OrderByInput',
    '_Telemetry_y_OrderByInput',
    '_Telemetry_heading_OrderByInput',
]



# recursive Telemetry types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TelemetryRelationFilter = TypedDict(
    'TelemetryRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TelemetryListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TelemetryInclude(TypedDict, total=False):
    """Telemetry relational arguments"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetry']


    

class TurtleBotIncludeFromTelemetry(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTelemetryRecursive1']
    battery: Union[bool, 'FindManyBatteryArgsFromTelemetryRecursive1']
    camera: Union[bool, 'FindManyCameraArgsFromTelemetryRecursive1']
    lidar: Union[bool, 'FindManyLidarArgsFromTelemetryRecursive1']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTelemetryRecursive1']
    map: Union[bool, 'FindManyMapArgsFromTelemetryRecursive1']


class TurtleBotIncludeFromTelemetryRecursive1(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTelemetryRecursive2']
    battery: Union[bool, 'FindManyBatteryArgsFromTelemetryRecursive2']
    camera: Union[bool, 'FindManyCameraArgsFromTelemetryRecursive2']
    lidar: Union[bool, 'FindManyLidarArgsFromTelemetryRecursive2']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTelemetryRecursive2']
    map: Union[bool, 'FindManyMapArgsFromTelemetryRecursive2']


class TurtleBotIncludeFromTelemetryRecursive2(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTelemetryRecursive3']
    battery: Union[bool, 'FindManyBatteryArgsFromTelemetryRecursive3']
    camera: Union[bool, 'FindManyCameraArgsFromTelemetryRecursive3']
    lidar: Union[bool, 'FindManyLidarArgsFromTelemetryRecursive3']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTelemetryRecursive3']
    map: Union[bool, 'FindManyMapArgsFromTelemetryRecursive3']


class TurtleBotIncludeFromTelemetryRecursive3(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromTelemetryRecursive4']
    battery: Union[bool, 'FindManyBatteryArgsFromTelemetryRecursive4']
    camera: Union[bool, 'FindManyCameraArgsFromTelemetryRecursive4']
    lidar: Union[bool, 'FindManyLidarArgsFromTelemetryRecursive4']
    waypoint: Union[bool, 'FindManyWaypointArgsFromTelemetryRecursive4']
    map: Union[bool, 'FindManyMapArgsFromTelemetryRecursive4']


class TurtleBotIncludeFromTelemetryRecursive4(TypedDict, total=False):
    """Relational arguments for Telemetry"""

    

class TurtleBotArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class TurtleBotArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class TurtleBotArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class TurtleBotArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class TurtleBotArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    
    

class FindManyTurtleBotArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class FindManyTurtleBotArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class FindManyTurtleBotArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class FindManyTurtleBotArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class FindManyTurtleBotArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    
    

class TelemetryIncludeFromTelemetry(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive1']


class TelemetryIncludeFromTelemetryRecursive1(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive2']


class TelemetryIncludeFromTelemetryRecursive2(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive3']


class TelemetryIncludeFromTelemetryRecursive3(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive4']


class TelemetryIncludeFromTelemetryRecursive4(TypedDict, total=False):
    """Relational arguments for Telemetry"""

    

class TelemetryArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class TelemetryArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class TelemetryArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class TelemetryArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class TelemetryArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    
    

class FindManyTelemetryArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class FindManyTelemetryArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class FindManyTelemetryArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class FindManyTelemetryArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class FindManyTelemetryArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    
    

class BatteryIncludeFromTelemetry(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive1']


class BatteryIncludeFromTelemetryRecursive1(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive2']


class BatteryIncludeFromTelemetryRecursive2(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive3']


class BatteryIncludeFromTelemetryRecursive3(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive4']


class BatteryIncludeFromTelemetryRecursive4(TypedDict, total=False):
    """Relational arguments for Telemetry"""

    

class BatteryArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'BatteryIncludeFromBatteryRecursive1'


class BatteryArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'BatteryIncludeFromBatteryRecursive2'


class BatteryArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'BatteryIncludeFromBatteryRecursive3'


class BatteryArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'BatteryIncludeFromBatteryRecursive4'


class BatteryArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    
    

class FindManyBatteryArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive1'


class FindManyBatteryArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive2'


class FindManyBatteryArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive3'


class FindManyBatteryArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive4'


class FindManyBatteryArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    
    

class CameraIncludeFromTelemetry(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive1']


class CameraIncludeFromTelemetryRecursive1(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive2']


class CameraIncludeFromTelemetryRecursive2(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive3']


class CameraIncludeFromTelemetryRecursive3(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive4']


class CameraIncludeFromTelemetryRecursive4(TypedDict, total=False):
    """Relational arguments for Telemetry"""

    

class CameraArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'CameraIncludeFromCameraRecursive1'


class CameraArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'CameraIncludeFromCameraRecursive2'


class CameraArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'CameraIncludeFromCameraRecursive3'


class CameraArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'CameraIncludeFromCameraRecursive4'


class CameraArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    
    

class FindManyCameraArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive1'


class FindManyCameraArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive2'


class FindManyCameraArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive3'


class FindManyCameraArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive4'


class FindManyCameraArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    
    

class LidarIncludeFromTelemetry(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive1']


class LidarIncludeFromTelemetryRecursive1(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive2']


class LidarIncludeFromTelemetryRecursive2(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive3']


class LidarIncludeFromTelemetryRecursive3(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive4']


class LidarIncludeFromTelemetryRecursive4(TypedDict, total=False):
    """Relational arguments for Telemetry"""

    

class LidarArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'LidarIncludeFromLidarRecursive1'


class LidarArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'LidarIncludeFromLidarRecursive2'


class LidarArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'LidarIncludeFromLidarRecursive3'


class LidarArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'LidarIncludeFromLidarRecursive4'


class LidarArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    
    

class FindManyLidarArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive1'


class FindManyLidarArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive2'


class FindManyLidarArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive3'


class FindManyLidarArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive4'


class FindManyLidarArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    
    

class WaypointIncludeFromTelemetry(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive1']


class WaypointIncludeFromTelemetryRecursive1(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive2']


class WaypointIncludeFromTelemetryRecursive2(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive3']


class WaypointIncludeFromTelemetryRecursive3(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive4']


class WaypointIncludeFromTelemetryRecursive4(TypedDict, total=False):
    """Relational arguments for Telemetry"""

    

class WaypointArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'WaypointIncludeFromWaypointRecursive1'


class WaypointArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'WaypointIncludeFromWaypointRecursive2'


class WaypointArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'WaypointIncludeFromWaypointRecursive3'


class WaypointArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'WaypointIncludeFromWaypointRecursive4'


class WaypointArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    
    

class FindManyWaypointArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive1'


class FindManyWaypointArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive2'


class FindManyWaypointArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive3'


class FindManyWaypointArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive4'


class FindManyWaypointArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    
    

class MapIncludeFromTelemetry(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive1']


class MapIncludeFromTelemetryRecursive1(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive2']


class MapIncludeFromTelemetryRecursive2(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive3']


class MapIncludeFromTelemetryRecursive3(TypedDict, total=False):
    """Relational arguments for Telemetry"""
    turtleBot: Union[bool, 'TurtleBotArgsFromTelemetryRecursive4']


class MapIncludeFromTelemetryRecursive4(TypedDict, total=False):
    """Relational arguments for Telemetry"""

    

class MapArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'MapIncludeFromMapRecursive1'


class MapArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'MapIncludeFromMapRecursive2'


class MapArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'MapIncludeFromMapRecursive3'


class MapArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    include: 'MapIncludeFromMapRecursive4'


class MapArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    
    

class FindManyMapArgsFromTelemetry(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive1'


class FindManyMapArgsFromTelemetryRecursive1(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive2'


class FindManyMapArgsFromTelemetryRecursive2(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive3'


class FindManyMapArgsFromTelemetryRecursive3(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive4'


class FindManyMapArgsFromTelemetryRecursive4(TypedDict, total=False):
    """Arguments for Telemetry"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    


FindManyTelemetryArgs = FindManyTelemetryArgsFromTelemetry
FindFirstTelemetryArgs = FindManyTelemetryArgsFromTelemetry


    

class TelemetryWhereInput(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    heading: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['TelemetryWhereInputRecursive1', List['TelemetryWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TelemetryWhereInputRecursive1']
    OR: List['TelemetryWhereInputRecursive1']
    NOT: List['TelemetryWhereInputRecursive1']


class TelemetryWhereInputRecursive1(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    heading: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['TelemetryWhereInputRecursive2', List['TelemetryWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TelemetryWhereInputRecursive2']
    OR: List['TelemetryWhereInputRecursive2']
    NOT: List['TelemetryWhereInputRecursive2']


class TelemetryWhereInputRecursive2(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    heading: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['TelemetryWhereInputRecursive3', List['TelemetryWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TelemetryWhereInputRecursive3']
    OR: List['TelemetryWhereInputRecursive3']
    NOT: List['TelemetryWhereInputRecursive3']


class TelemetryWhereInputRecursive3(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    heading: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['TelemetryWhereInputRecursive4', List['TelemetryWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TelemetryWhereInputRecursive4']
    OR: List['TelemetryWhereInputRecursive4']
    NOT: List['TelemetryWhereInputRecursive4']


class TelemetryWhereInputRecursive4(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    heading: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'



# aggregate Telemetry types


    

class TelemetryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    heading: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TelemetryScalarWhereWithAggregatesInputRecursive1']
    OR: List['TelemetryScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TelemetryScalarWhereWithAggregatesInputRecursive1']


class TelemetryScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    heading: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TelemetryScalarWhereWithAggregatesInputRecursive2']
    OR: List['TelemetryScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TelemetryScalarWhereWithAggregatesInputRecursive2']


class TelemetryScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    heading: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TelemetryScalarWhereWithAggregatesInputRecursive3']
    OR: List['TelemetryScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TelemetryScalarWhereWithAggregatesInputRecursive3']


class TelemetryScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    heading: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TelemetryScalarWhereWithAggregatesInputRecursive4']
    OR: List['TelemetryScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TelemetryScalarWhereWithAggregatesInputRecursive4']


class TelemetryScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Telemetry arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    heading: Union[_float, 'types.FloatWithAggregatesFilter']



class TelemetryGroupByOutput(TypedDict, total=False):
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    x: _float
    y: _float
    heading: _float
    _sum: 'TelemetrySumAggregateOutput'
    _avg: 'TelemetryAvgAggregateOutput'
    _min: 'TelemetryMinAggregateOutput'
    _max: 'TelemetryMaxAggregateOutput'
    _count: 'TelemetryCountAggregateOutput'


class TelemetryAvgAggregateOutput(TypedDict, total=False):
    """Telemetry output for aggregating averages"""
    id: float
    turtleBotId: float
    x: float
    y: float
    heading: float


class TelemetrySumAggregateOutput(TypedDict, total=False):
    """Telemetry output for aggregating sums"""
    id: _int
    turtleBotId: _int
    x: _float
    y: _float
    heading: _float


class TelemetryScalarAggregateOutput(TypedDict, total=False):
    """Telemetry output including scalar fields"""
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    x: _float
    y: _float
    heading: _float


TelemetryMinAggregateOutput = TelemetryScalarAggregateOutput
TelemetryMaxAggregateOutput = TelemetryScalarAggregateOutput


class TelemetryMaxAggregateInput(TypedDict, total=False):
    """Telemetry input for aggregating by max"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    x: bool
    y: bool
    heading: bool


class TelemetryMinAggregateInput(TypedDict, total=False):
    """Telemetry input for aggregating by min"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    x: bool
    y: bool
    heading: bool


class TelemetryNumberAggregateInput(TypedDict, total=False):
    """Telemetry input for aggregating numbers"""
    id: bool
    turtleBotId: bool
    x: bool
    y: bool
    heading: bool


TelemetryAvgAggregateInput = TelemetryNumberAggregateInput
TelemetrySumAggregateInput = TelemetryNumberAggregateInput


TelemetryCountAggregateInput = TypedDict(
    'TelemetryCountAggregateInput',
    {
        'id': bool,
        'turtleBotId': bool,
        'timestamp': bool,
        'x': bool,
        'y': bool,
        'heading': bool,
        '_all': bool,
    },
    total=False,
)

TelemetryCountAggregateOutput = TypedDict(
    'TelemetryCountAggregateOutput',
    {
        'id': int,
        'turtleBotId': int,
        'timestamp': int,
        'x': int,
        'y': int,
        'heading': int,
        '_all': int,
    },
    total=False,
)


TelemetryKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'x',
    'y',
    'heading',
    'turtleBot',
]
TelemetryScalarFieldKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'x',
    'y',
    'heading',
]
TelemetryScalarFieldKeysT = TypeVar('TelemetryScalarFieldKeysT', bound=TelemetryScalarFieldKeys)

TelemetryRelationalFieldKeys = Literal[
        'turtleBot',
    ]

# Battery types

class BatteryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Battery create method"""
    id: _int
    turtleBotId: _int
    turtleBot: 'TurtleBotCreateNestedWithoutRelationsInput'


class BatteryCreateInput(BatteryOptionalCreateInput):
    """Required arguments to the Battery create method"""
    timestamp: datetime.datetime
    voltage: _float
    current: _float
    percentage: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BatteryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Battery create method, without relations"""
    id: _int
    turtleBotId: _int


class BatteryCreateWithoutRelationsInput(BatteryOptionalCreateWithoutRelationsInput):
    """Required arguments to the Battery create method, without relations"""
    timestamp: datetime.datetime
    voltage: _float
    current: _float
    percentage: _float


class BatteryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BatteryCreateWithoutRelationsInput'
    connect: 'BatteryWhereUniqueInput'


class BatteryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BatteryCreateWithoutRelationsInput', List['BatteryCreateWithoutRelationsInput']]
    connect: Union['BatteryWhereUniqueInput', List['BatteryWhereUniqueInput']]


_BatteryWhereUnique_id_Input = TypedDict(
    '_BatteryWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

BatteryWhereUniqueInput = _BatteryWhereUnique_id_Input


class BatteryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    voltage: Union[AtomicFloatInput, _float]
    current: Union[AtomicFloatInput, _float]
    percentage: Union[AtomicFloatInput, _float]
    turtleBot: 'TurtleBotUpdateOneWithoutRelationsInput'


class BatteryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    voltage: Union[AtomicFloatInput, _float]
    current: Union[AtomicFloatInput, _float]
    percentage: Union[AtomicFloatInput, _float]


class BatteryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BatteryCreateWithoutRelationsInput']
    connect: List['BatteryWhereUniqueInput']
    set: List['BatteryWhereUniqueInput']
    disconnect: List['BatteryWhereUniqueInput']
    delete: List['BatteryWhereUniqueInput']

    # TODO
    # update: List['BatteryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BatteryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BatteryScalarWhereInput']
    # upsert: List['BatteryUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['BatteryCreateOrConnectWithoutRelationsInput']


class BatteryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BatteryCreateWithoutRelationsInput'
    connect: 'BatteryWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BatteryUpdateInput'
    # upsert: 'BatteryUpsertWithoutRelationsInput'
    # connectOrCreate: 'BatteryCreateOrConnectWithoutRelationsInput'


class BatteryUpsertInput(TypedDict):
    create: 'BatteryCreateInput'
    update: 'BatteryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Battery_id_OrderByInput = TypedDict(
    '_Battery_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Battery_turtleBotId_OrderByInput = TypedDict(
    '_Battery_turtleBotId_OrderByInput',
    {
        'turtleBotId': 'SortOrder',
    },
    total=True
)

_Battery_timestamp_OrderByInput = TypedDict(
    '_Battery_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_Battery_voltage_OrderByInput = TypedDict(
    '_Battery_voltage_OrderByInput',
    {
        'voltage': 'SortOrder',
    },
    total=True
)

_Battery_current_OrderByInput = TypedDict(
    '_Battery_current_OrderByInput',
    {
        'current': 'SortOrder',
    },
    total=True
)

_Battery_percentage_OrderByInput = TypedDict(
    '_Battery_percentage_OrderByInput',
    {
        'percentage': 'SortOrder',
    },
    total=True
)

BatteryOrderByInput = Union[
    '_Battery_id_OrderByInput',
    '_Battery_turtleBotId_OrderByInput',
    '_Battery_timestamp_OrderByInput',
    '_Battery_voltage_OrderByInput',
    '_Battery_current_OrderByInput',
    '_Battery_percentage_OrderByInput',
]



# recursive Battery types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

BatteryRelationFilter = TypedDict(
    'BatteryRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class BatteryListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class BatteryInclude(TypedDict, total=False):
    """Battery relational arguments"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBattery']


    

class TurtleBotIncludeFromBattery(TypedDict, total=False):
    """Relational arguments for Battery"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromBatteryRecursive1']
    battery: Union[bool, 'FindManyBatteryArgsFromBatteryRecursive1']
    camera: Union[bool, 'FindManyCameraArgsFromBatteryRecursive1']
    lidar: Union[bool, 'FindManyLidarArgsFromBatteryRecursive1']
    waypoint: Union[bool, 'FindManyWaypointArgsFromBatteryRecursive1']
    map: Union[bool, 'FindManyMapArgsFromBatteryRecursive1']


class TurtleBotIncludeFromBatteryRecursive1(TypedDict, total=False):
    """Relational arguments for Battery"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromBatteryRecursive2']
    battery: Union[bool, 'FindManyBatteryArgsFromBatteryRecursive2']
    camera: Union[bool, 'FindManyCameraArgsFromBatteryRecursive2']
    lidar: Union[bool, 'FindManyLidarArgsFromBatteryRecursive2']
    waypoint: Union[bool, 'FindManyWaypointArgsFromBatteryRecursive2']
    map: Union[bool, 'FindManyMapArgsFromBatteryRecursive2']


class TurtleBotIncludeFromBatteryRecursive2(TypedDict, total=False):
    """Relational arguments for Battery"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromBatteryRecursive3']
    battery: Union[bool, 'FindManyBatteryArgsFromBatteryRecursive3']
    camera: Union[bool, 'FindManyCameraArgsFromBatteryRecursive3']
    lidar: Union[bool, 'FindManyLidarArgsFromBatteryRecursive3']
    waypoint: Union[bool, 'FindManyWaypointArgsFromBatteryRecursive3']
    map: Union[bool, 'FindManyMapArgsFromBatteryRecursive3']


class TurtleBotIncludeFromBatteryRecursive3(TypedDict, total=False):
    """Relational arguments for Battery"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromBatteryRecursive4']
    battery: Union[bool, 'FindManyBatteryArgsFromBatteryRecursive4']
    camera: Union[bool, 'FindManyCameraArgsFromBatteryRecursive4']
    lidar: Union[bool, 'FindManyLidarArgsFromBatteryRecursive4']
    waypoint: Union[bool, 'FindManyWaypointArgsFromBatteryRecursive4']
    map: Union[bool, 'FindManyMapArgsFromBatteryRecursive4']


class TurtleBotIncludeFromBatteryRecursive4(TypedDict, total=False):
    """Relational arguments for Battery"""

    

class TurtleBotArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class TurtleBotArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class TurtleBotArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class TurtleBotArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class TurtleBotArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    
    

class FindManyTurtleBotArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class FindManyTurtleBotArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class FindManyTurtleBotArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class FindManyTurtleBotArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class FindManyTurtleBotArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    
    

class TelemetryIncludeFromBattery(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive1']


class TelemetryIncludeFromBatteryRecursive1(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive2']


class TelemetryIncludeFromBatteryRecursive2(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive3']


class TelemetryIncludeFromBatteryRecursive3(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive4']


class TelemetryIncludeFromBatteryRecursive4(TypedDict, total=False):
    """Relational arguments for Battery"""

    

class TelemetryArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class TelemetryArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class TelemetryArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class TelemetryArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class TelemetryArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    
    

class FindManyTelemetryArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class FindManyTelemetryArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class FindManyTelemetryArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class FindManyTelemetryArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class FindManyTelemetryArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    
    

class BatteryIncludeFromBattery(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive1']


class BatteryIncludeFromBatteryRecursive1(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive2']


class BatteryIncludeFromBatteryRecursive2(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive3']


class BatteryIncludeFromBatteryRecursive3(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive4']


class BatteryIncludeFromBatteryRecursive4(TypedDict, total=False):
    """Relational arguments for Battery"""

    

class BatteryArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'BatteryIncludeFromBatteryRecursive1'


class BatteryArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'BatteryIncludeFromBatteryRecursive2'


class BatteryArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'BatteryIncludeFromBatteryRecursive3'


class BatteryArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'BatteryIncludeFromBatteryRecursive4'


class BatteryArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    
    

class FindManyBatteryArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive1'


class FindManyBatteryArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive2'


class FindManyBatteryArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive3'


class FindManyBatteryArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive4'


class FindManyBatteryArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    
    

class CameraIncludeFromBattery(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive1']


class CameraIncludeFromBatteryRecursive1(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive2']


class CameraIncludeFromBatteryRecursive2(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive3']


class CameraIncludeFromBatteryRecursive3(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive4']


class CameraIncludeFromBatteryRecursive4(TypedDict, total=False):
    """Relational arguments for Battery"""

    

class CameraArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'CameraIncludeFromCameraRecursive1'


class CameraArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'CameraIncludeFromCameraRecursive2'


class CameraArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'CameraIncludeFromCameraRecursive3'


class CameraArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'CameraIncludeFromCameraRecursive4'


class CameraArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    
    

class FindManyCameraArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive1'


class FindManyCameraArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive2'


class FindManyCameraArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive3'


class FindManyCameraArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive4'


class FindManyCameraArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    
    

class LidarIncludeFromBattery(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive1']


class LidarIncludeFromBatteryRecursive1(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive2']


class LidarIncludeFromBatteryRecursive2(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive3']


class LidarIncludeFromBatteryRecursive3(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive4']


class LidarIncludeFromBatteryRecursive4(TypedDict, total=False):
    """Relational arguments for Battery"""

    

class LidarArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'LidarIncludeFromLidarRecursive1'


class LidarArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'LidarIncludeFromLidarRecursive2'


class LidarArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'LidarIncludeFromLidarRecursive3'


class LidarArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'LidarIncludeFromLidarRecursive4'


class LidarArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    
    

class FindManyLidarArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive1'


class FindManyLidarArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive2'


class FindManyLidarArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive3'


class FindManyLidarArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive4'


class FindManyLidarArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    
    

class WaypointIncludeFromBattery(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive1']


class WaypointIncludeFromBatteryRecursive1(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive2']


class WaypointIncludeFromBatteryRecursive2(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive3']


class WaypointIncludeFromBatteryRecursive3(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive4']


class WaypointIncludeFromBatteryRecursive4(TypedDict, total=False):
    """Relational arguments for Battery"""

    

class WaypointArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'WaypointIncludeFromWaypointRecursive1'


class WaypointArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'WaypointIncludeFromWaypointRecursive2'


class WaypointArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'WaypointIncludeFromWaypointRecursive3'


class WaypointArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'WaypointIncludeFromWaypointRecursive4'


class WaypointArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    
    

class FindManyWaypointArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive1'


class FindManyWaypointArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive2'


class FindManyWaypointArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive3'


class FindManyWaypointArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive4'


class FindManyWaypointArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    
    

class MapIncludeFromBattery(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive1']


class MapIncludeFromBatteryRecursive1(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive2']


class MapIncludeFromBatteryRecursive2(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive3']


class MapIncludeFromBatteryRecursive3(TypedDict, total=False):
    """Relational arguments for Battery"""
    turtleBot: Union[bool, 'TurtleBotArgsFromBatteryRecursive4']


class MapIncludeFromBatteryRecursive4(TypedDict, total=False):
    """Relational arguments for Battery"""

    

class MapArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'MapIncludeFromMapRecursive1'


class MapArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'MapIncludeFromMapRecursive2'


class MapArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'MapIncludeFromMapRecursive3'


class MapArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    include: 'MapIncludeFromMapRecursive4'


class MapArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    
    

class FindManyMapArgsFromBattery(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive1'


class FindManyMapArgsFromBatteryRecursive1(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive2'


class FindManyMapArgsFromBatteryRecursive2(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive3'


class FindManyMapArgsFromBatteryRecursive3(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive4'


class FindManyMapArgsFromBatteryRecursive4(TypedDict, total=False):
    """Arguments for Battery"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    


FindManyBatteryArgs = FindManyBatteryArgsFromBattery
FindFirstBatteryArgs = FindManyBatteryArgsFromBattery


    

class BatteryWhereInput(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    voltage: Union[_float, 'types.FloatFilter']
    current: Union[_float, 'types.FloatFilter']
    percentage: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['BatteryWhereInputRecursive1', List['BatteryWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['BatteryWhereInputRecursive1']
    OR: List['BatteryWhereInputRecursive1']
    NOT: List['BatteryWhereInputRecursive1']


class BatteryWhereInputRecursive1(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    voltage: Union[_float, 'types.FloatFilter']
    current: Union[_float, 'types.FloatFilter']
    percentage: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['BatteryWhereInputRecursive2', List['BatteryWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['BatteryWhereInputRecursive2']
    OR: List['BatteryWhereInputRecursive2']
    NOT: List['BatteryWhereInputRecursive2']


class BatteryWhereInputRecursive2(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    voltage: Union[_float, 'types.FloatFilter']
    current: Union[_float, 'types.FloatFilter']
    percentage: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['BatteryWhereInputRecursive3', List['BatteryWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['BatteryWhereInputRecursive3']
    OR: List['BatteryWhereInputRecursive3']
    NOT: List['BatteryWhereInputRecursive3']


class BatteryWhereInputRecursive3(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    voltage: Union[_float, 'types.FloatFilter']
    current: Union[_float, 'types.FloatFilter']
    percentage: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['BatteryWhereInputRecursive4', List['BatteryWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['BatteryWhereInputRecursive4']
    OR: List['BatteryWhereInputRecursive4']
    NOT: List['BatteryWhereInputRecursive4']


class BatteryWhereInputRecursive4(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    voltage: Union[_float, 'types.FloatFilter']
    current: Union[_float, 'types.FloatFilter']
    percentage: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'



# aggregate Battery types


    

class BatteryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    voltage: Union[_float, 'types.FloatWithAggregatesFilter']
    current: Union[_float, 'types.FloatWithAggregatesFilter']
    percentage: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['BatteryScalarWhereWithAggregatesInputRecursive1']
    OR: List['BatteryScalarWhereWithAggregatesInputRecursive1']
    NOT: List['BatteryScalarWhereWithAggregatesInputRecursive1']


class BatteryScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    voltage: Union[_float, 'types.FloatWithAggregatesFilter']
    current: Union[_float, 'types.FloatWithAggregatesFilter']
    percentage: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['BatteryScalarWhereWithAggregatesInputRecursive2']
    OR: List['BatteryScalarWhereWithAggregatesInputRecursive2']
    NOT: List['BatteryScalarWhereWithAggregatesInputRecursive2']


class BatteryScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    voltage: Union[_float, 'types.FloatWithAggregatesFilter']
    current: Union[_float, 'types.FloatWithAggregatesFilter']
    percentage: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['BatteryScalarWhereWithAggregatesInputRecursive3']
    OR: List['BatteryScalarWhereWithAggregatesInputRecursive3']
    NOT: List['BatteryScalarWhereWithAggregatesInputRecursive3']


class BatteryScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    voltage: Union[_float, 'types.FloatWithAggregatesFilter']
    current: Union[_float, 'types.FloatWithAggregatesFilter']
    percentage: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['BatteryScalarWhereWithAggregatesInputRecursive4']
    OR: List['BatteryScalarWhereWithAggregatesInputRecursive4']
    NOT: List['BatteryScalarWhereWithAggregatesInputRecursive4']


class BatteryScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Battery arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    voltage: Union[_float, 'types.FloatWithAggregatesFilter']
    current: Union[_float, 'types.FloatWithAggregatesFilter']
    percentage: Union[_float, 'types.FloatWithAggregatesFilter']



class BatteryGroupByOutput(TypedDict, total=False):
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    voltage: _float
    current: _float
    percentage: _float
    _sum: 'BatterySumAggregateOutput'
    _avg: 'BatteryAvgAggregateOutput'
    _min: 'BatteryMinAggregateOutput'
    _max: 'BatteryMaxAggregateOutput'
    _count: 'BatteryCountAggregateOutput'


class BatteryAvgAggregateOutput(TypedDict, total=False):
    """Battery output for aggregating averages"""
    id: float
    turtleBotId: float
    voltage: float
    current: float
    percentage: float


class BatterySumAggregateOutput(TypedDict, total=False):
    """Battery output for aggregating sums"""
    id: _int
    turtleBotId: _int
    voltage: _float
    current: _float
    percentage: _float


class BatteryScalarAggregateOutput(TypedDict, total=False):
    """Battery output including scalar fields"""
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    voltage: _float
    current: _float
    percentage: _float


BatteryMinAggregateOutput = BatteryScalarAggregateOutput
BatteryMaxAggregateOutput = BatteryScalarAggregateOutput


class BatteryMaxAggregateInput(TypedDict, total=False):
    """Battery input for aggregating by max"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    voltage: bool
    current: bool
    percentage: bool


class BatteryMinAggregateInput(TypedDict, total=False):
    """Battery input for aggregating by min"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    voltage: bool
    current: bool
    percentage: bool


class BatteryNumberAggregateInput(TypedDict, total=False):
    """Battery input for aggregating numbers"""
    id: bool
    turtleBotId: bool
    voltage: bool
    current: bool
    percentage: bool


BatteryAvgAggregateInput = BatteryNumberAggregateInput
BatterySumAggregateInput = BatteryNumberAggregateInput


BatteryCountAggregateInput = TypedDict(
    'BatteryCountAggregateInput',
    {
        'id': bool,
        'turtleBotId': bool,
        'timestamp': bool,
        'voltage': bool,
        'current': bool,
        'percentage': bool,
        '_all': bool,
    },
    total=False,
)

BatteryCountAggregateOutput = TypedDict(
    'BatteryCountAggregateOutput',
    {
        'id': int,
        'turtleBotId': int,
        'timestamp': int,
        'voltage': int,
        'current': int,
        'percentage': int,
        '_all': int,
    },
    total=False,
)


BatteryKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'voltage',
    'current',
    'percentage',
    'turtleBot',
]
BatteryScalarFieldKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'voltage',
    'current',
    'percentage',
]
BatteryScalarFieldKeysT = TypeVar('BatteryScalarFieldKeysT', bound=BatteryScalarFieldKeys)

BatteryRelationalFieldKeys = Literal[
        'turtleBot',
    ]

# Camera types

class CameraOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Camera create method"""
    id: _int
    turtleBotId: _int
    turtleBot: 'TurtleBotCreateNestedWithoutRelationsInput'


class CameraCreateInput(CameraOptionalCreateInput):
    """Required arguments to the Camera create method"""
    timestamp: datetime.datetime
    image: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CameraOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Camera create method, without relations"""
    id: _int
    turtleBotId: _int


class CameraCreateWithoutRelationsInput(CameraOptionalCreateWithoutRelationsInput):
    """Required arguments to the Camera create method, without relations"""
    timestamp: datetime.datetime
    image: _str


class CameraCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CameraCreateWithoutRelationsInput'
    connect: 'CameraWhereUniqueInput'


class CameraCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CameraCreateWithoutRelationsInput', List['CameraCreateWithoutRelationsInput']]
    connect: Union['CameraWhereUniqueInput', List['CameraWhereUniqueInput']]


_CameraWhereUnique_id_Input = TypedDict(
    '_CameraWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

CameraWhereUniqueInput = _CameraWhereUnique_id_Input


class CameraUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    image: _str
    turtleBot: 'TurtleBotUpdateOneWithoutRelationsInput'


class CameraUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    image: _str


class CameraUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CameraCreateWithoutRelationsInput']
    connect: List['CameraWhereUniqueInput']
    set: List['CameraWhereUniqueInput']
    disconnect: List['CameraWhereUniqueInput']
    delete: List['CameraWhereUniqueInput']

    # TODO
    # update: List['CameraUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CameraUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CameraScalarWhereInput']
    # upsert: List['CameraUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['CameraCreateOrConnectWithoutRelationsInput']


class CameraUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CameraCreateWithoutRelationsInput'
    connect: 'CameraWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CameraUpdateInput'
    # upsert: 'CameraUpsertWithoutRelationsInput'
    # connectOrCreate: 'CameraCreateOrConnectWithoutRelationsInput'


class CameraUpsertInput(TypedDict):
    create: 'CameraCreateInput'
    update: 'CameraUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Camera_id_OrderByInput = TypedDict(
    '_Camera_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Camera_turtleBotId_OrderByInput = TypedDict(
    '_Camera_turtleBotId_OrderByInput',
    {
        'turtleBotId': 'SortOrder',
    },
    total=True
)

_Camera_timestamp_OrderByInput = TypedDict(
    '_Camera_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_Camera_image_OrderByInput = TypedDict(
    '_Camera_image_OrderByInput',
    {
        'image': 'SortOrder',
    },
    total=True
)

CameraOrderByInput = Union[
    '_Camera_id_OrderByInput',
    '_Camera_turtleBotId_OrderByInput',
    '_Camera_timestamp_OrderByInput',
    '_Camera_image_OrderByInput',
]



# recursive Camera types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CameraRelationFilter = TypedDict(
    'CameraRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CameraListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CameraInclude(TypedDict, total=False):
    """Camera relational arguments"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCamera']


    

class TurtleBotIncludeFromCamera(TypedDict, total=False):
    """Relational arguments for Camera"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromCameraRecursive1']
    battery: Union[bool, 'FindManyBatteryArgsFromCameraRecursive1']
    camera: Union[bool, 'FindManyCameraArgsFromCameraRecursive1']
    lidar: Union[bool, 'FindManyLidarArgsFromCameraRecursive1']
    waypoint: Union[bool, 'FindManyWaypointArgsFromCameraRecursive1']
    map: Union[bool, 'FindManyMapArgsFromCameraRecursive1']


class TurtleBotIncludeFromCameraRecursive1(TypedDict, total=False):
    """Relational arguments for Camera"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromCameraRecursive2']
    battery: Union[bool, 'FindManyBatteryArgsFromCameraRecursive2']
    camera: Union[bool, 'FindManyCameraArgsFromCameraRecursive2']
    lidar: Union[bool, 'FindManyLidarArgsFromCameraRecursive2']
    waypoint: Union[bool, 'FindManyWaypointArgsFromCameraRecursive2']
    map: Union[bool, 'FindManyMapArgsFromCameraRecursive2']


class TurtleBotIncludeFromCameraRecursive2(TypedDict, total=False):
    """Relational arguments for Camera"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromCameraRecursive3']
    battery: Union[bool, 'FindManyBatteryArgsFromCameraRecursive3']
    camera: Union[bool, 'FindManyCameraArgsFromCameraRecursive3']
    lidar: Union[bool, 'FindManyLidarArgsFromCameraRecursive3']
    waypoint: Union[bool, 'FindManyWaypointArgsFromCameraRecursive3']
    map: Union[bool, 'FindManyMapArgsFromCameraRecursive3']


class TurtleBotIncludeFromCameraRecursive3(TypedDict, total=False):
    """Relational arguments for Camera"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromCameraRecursive4']
    battery: Union[bool, 'FindManyBatteryArgsFromCameraRecursive4']
    camera: Union[bool, 'FindManyCameraArgsFromCameraRecursive4']
    lidar: Union[bool, 'FindManyLidarArgsFromCameraRecursive4']
    waypoint: Union[bool, 'FindManyWaypointArgsFromCameraRecursive4']
    map: Union[bool, 'FindManyMapArgsFromCameraRecursive4']


class TurtleBotIncludeFromCameraRecursive4(TypedDict, total=False):
    """Relational arguments for Camera"""

    

class TurtleBotArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class TurtleBotArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class TurtleBotArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class TurtleBotArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class TurtleBotArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    
    

class FindManyTurtleBotArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class FindManyTurtleBotArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class FindManyTurtleBotArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class FindManyTurtleBotArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class FindManyTurtleBotArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    
    

class TelemetryIncludeFromCamera(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive1']


class TelemetryIncludeFromCameraRecursive1(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive2']


class TelemetryIncludeFromCameraRecursive2(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive3']


class TelemetryIncludeFromCameraRecursive3(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive4']


class TelemetryIncludeFromCameraRecursive4(TypedDict, total=False):
    """Relational arguments for Camera"""

    

class TelemetryArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class TelemetryArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class TelemetryArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class TelemetryArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class TelemetryArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    
    

class FindManyTelemetryArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class FindManyTelemetryArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class FindManyTelemetryArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class FindManyTelemetryArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class FindManyTelemetryArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    
    

class BatteryIncludeFromCamera(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive1']


class BatteryIncludeFromCameraRecursive1(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive2']


class BatteryIncludeFromCameraRecursive2(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive3']


class BatteryIncludeFromCameraRecursive3(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive4']


class BatteryIncludeFromCameraRecursive4(TypedDict, total=False):
    """Relational arguments for Camera"""

    

class BatteryArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'BatteryIncludeFromBatteryRecursive1'


class BatteryArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'BatteryIncludeFromBatteryRecursive2'


class BatteryArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'BatteryIncludeFromBatteryRecursive3'


class BatteryArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'BatteryIncludeFromBatteryRecursive4'


class BatteryArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    
    

class FindManyBatteryArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive1'


class FindManyBatteryArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive2'


class FindManyBatteryArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive3'


class FindManyBatteryArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive4'


class FindManyBatteryArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    
    

class CameraIncludeFromCamera(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive1']


class CameraIncludeFromCameraRecursive1(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive2']


class CameraIncludeFromCameraRecursive2(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive3']


class CameraIncludeFromCameraRecursive3(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive4']


class CameraIncludeFromCameraRecursive4(TypedDict, total=False):
    """Relational arguments for Camera"""

    

class CameraArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'CameraIncludeFromCameraRecursive1'


class CameraArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'CameraIncludeFromCameraRecursive2'


class CameraArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'CameraIncludeFromCameraRecursive3'


class CameraArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'CameraIncludeFromCameraRecursive4'


class CameraArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    
    

class FindManyCameraArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive1'


class FindManyCameraArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive2'


class FindManyCameraArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive3'


class FindManyCameraArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive4'


class FindManyCameraArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    
    

class LidarIncludeFromCamera(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive1']


class LidarIncludeFromCameraRecursive1(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive2']


class LidarIncludeFromCameraRecursive2(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive3']


class LidarIncludeFromCameraRecursive3(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive4']


class LidarIncludeFromCameraRecursive4(TypedDict, total=False):
    """Relational arguments for Camera"""

    

class LidarArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'LidarIncludeFromLidarRecursive1'


class LidarArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'LidarIncludeFromLidarRecursive2'


class LidarArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'LidarIncludeFromLidarRecursive3'


class LidarArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'LidarIncludeFromLidarRecursive4'


class LidarArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    
    

class FindManyLidarArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive1'


class FindManyLidarArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive2'


class FindManyLidarArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive3'


class FindManyLidarArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive4'


class FindManyLidarArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    
    

class WaypointIncludeFromCamera(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive1']


class WaypointIncludeFromCameraRecursive1(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive2']


class WaypointIncludeFromCameraRecursive2(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive3']


class WaypointIncludeFromCameraRecursive3(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive4']


class WaypointIncludeFromCameraRecursive4(TypedDict, total=False):
    """Relational arguments for Camera"""

    

class WaypointArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'WaypointIncludeFromWaypointRecursive1'


class WaypointArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'WaypointIncludeFromWaypointRecursive2'


class WaypointArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'WaypointIncludeFromWaypointRecursive3'


class WaypointArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'WaypointIncludeFromWaypointRecursive4'


class WaypointArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    
    

class FindManyWaypointArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive1'


class FindManyWaypointArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive2'


class FindManyWaypointArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive3'


class FindManyWaypointArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive4'


class FindManyWaypointArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    
    

class MapIncludeFromCamera(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive1']


class MapIncludeFromCameraRecursive1(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive2']


class MapIncludeFromCameraRecursive2(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive3']


class MapIncludeFromCameraRecursive3(TypedDict, total=False):
    """Relational arguments for Camera"""
    turtleBot: Union[bool, 'TurtleBotArgsFromCameraRecursive4']


class MapIncludeFromCameraRecursive4(TypedDict, total=False):
    """Relational arguments for Camera"""

    

class MapArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'MapIncludeFromMapRecursive1'


class MapArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'MapIncludeFromMapRecursive2'


class MapArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'MapIncludeFromMapRecursive3'


class MapArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    include: 'MapIncludeFromMapRecursive4'


class MapArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    
    

class FindManyMapArgsFromCamera(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive1'


class FindManyMapArgsFromCameraRecursive1(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive2'


class FindManyMapArgsFromCameraRecursive2(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive3'


class FindManyMapArgsFromCameraRecursive3(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive4'


class FindManyMapArgsFromCameraRecursive4(TypedDict, total=False):
    """Arguments for Camera"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    


FindManyCameraArgs = FindManyCameraArgsFromCamera
FindFirstCameraArgs = FindManyCameraArgsFromCamera


    

class CameraWhereInput(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    image: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['CameraWhereInputRecursive1', List['CameraWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CameraWhereInputRecursive1']
    OR: List['CameraWhereInputRecursive1']
    NOT: List['CameraWhereInputRecursive1']


class CameraWhereInputRecursive1(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    image: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['CameraWhereInputRecursive2', List['CameraWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CameraWhereInputRecursive2']
    OR: List['CameraWhereInputRecursive2']
    NOT: List['CameraWhereInputRecursive2']


class CameraWhereInputRecursive2(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    image: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['CameraWhereInputRecursive3', List['CameraWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CameraWhereInputRecursive3']
    OR: List['CameraWhereInputRecursive3']
    NOT: List['CameraWhereInputRecursive3']


class CameraWhereInputRecursive3(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    image: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['CameraWhereInputRecursive4', List['CameraWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CameraWhereInputRecursive4']
    OR: List['CameraWhereInputRecursive4']
    NOT: List['CameraWhereInputRecursive4']


class CameraWhereInputRecursive4(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    image: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'



# aggregate Camera types


    

class CameraScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CameraScalarWhereWithAggregatesInputRecursive1']
    OR: List['CameraScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CameraScalarWhereWithAggregatesInputRecursive1']


class CameraScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CameraScalarWhereWithAggregatesInputRecursive2']
    OR: List['CameraScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CameraScalarWhereWithAggregatesInputRecursive2']


class CameraScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CameraScalarWhereWithAggregatesInputRecursive3']
    OR: List['CameraScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CameraScalarWhereWithAggregatesInputRecursive3']


class CameraScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CameraScalarWhereWithAggregatesInputRecursive4']
    OR: List['CameraScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CameraScalarWhereWithAggregatesInputRecursive4']


class CameraScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Camera arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']



class CameraGroupByOutput(TypedDict, total=False):
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    image: _str
    _sum: 'CameraSumAggregateOutput'
    _avg: 'CameraAvgAggregateOutput'
    _min: 'CameraMinAggregateOutput'
    _max: 'CameraMaxAggregateOutput'
    _count: 'CameraCountAggregateOutput'


class CameraAvgAggregateOutput(TypedDict, total=False):
    """Camera output for aggregating averages"""
    id: float
    turtleBotId: float


class CameraSumAggregateOutput(TypedDict, total=False):
    """Camera output for aggregating sums"""
    id: _int
    turtleBotId: _int


class CameraScalarAggregateOutput(TypedDict, total=False):
    """Camera output including scalar fields"""
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    image: _str


CameraMinAggregateOutput = CameraScalarAggregateOutput
CameraMaxAggregateOutput = CameraScalarAggregateOutput


class CameraMaxAggregateInput(TypedDict, total=False):
    """Camera input for aggregating by max"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    image: bool


class CameraMinAggregateInput(TypedDict, total=False):
    """Camera input for aggregating by min"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    image: bool


class CameraNumberAggregateInput(TypedDict, total=False):
    """Camera input for aggregating numbers"""
    id: bool
    turtleBotId: bool


CameraAvgAggregateInput = CameraNumberAggregateInput
CameraSumAggregateInput = CameraNumberAggregateInput


CameraCountAggregateInput = TypedDict(
    'CameraCountAggregateInput',
    {
        'id': bool,
        'turtleBotId': bool,
        'timestamp': bool,
        'image': bool,
        '_all': bool,
    },
    total=False,
)

CameraCountAggregateOutput = TypedDict(
    'CameraCountAggregateOutput',
    {
        'id': int,
        'turtleBotId': int,
        'timestamp': int,
        'image': int,
        '_all': int,
    },
    total=False,
)


CameraKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'image',
    'turtleBot',
]
CameraScalarFieldKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'image',
]
CameraScalarFieldKeysT = TypeVar('CameraScalarFieldKeysT', bound=CameraScalarFieldKeys)

CameraRelationalFieldKeys = Literal[
        'turtleBot',
    ]

# Lidar types

class LidarOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Lidar create method"""
    id: _int
    turtleBotId: _int
    turtleBot: 'TurtleBotCreateNestedWithoutRelationsInput'


class LidarCreateInput(LidarOptionalCreateInput):
    """Required arguments to the Lidar create method"""
    timestamp: datetime.datetime
    scan: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LidarOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Lidar create method, without relations"""
    id: _int
    turtleBotId: _int


class LidarCreateWithoutRelationsInput(LidarOptionalCreateWithoutRelationsInput):
    """Required arguments to the Lidar create method, without relations"""
    timestamp: datetime.datetime
    scan: _str


class LidarCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LidarCreateWithoutRelationsInput'
    connect: 'LidarWhereUniqueInput'


class LidarCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LidarCreateWithoutRelationsInput', List['LidarCreateWithoutRelationsInput']]
    connect: Union['LidarWhereUniqueInput', List['LidarWhereUniqueInput']]


_LidarWhereUnique_id_Input = TypedDict(
    '_LidarWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

LidarWhereUniqueInput = _LidarWhereUnique_id_Input


class LidarUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    scan: _str
    turtleBot: 'TurtleBotUpdateOneWithoutRelationsInput'


class LidarUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    scan: _str


class LidarUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LidarCreateWithoutRelationsInput']
    connect: List['LidarWhereUniqueInput']
    set: List['LidarWhereUniqueInput']
    disconnect: List['LidarWhereUniqueInput']
    delete: List['LidarWhereUniqueInput']

    # TODO
    # update: List['LidarUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LidarUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LidarScalarWhereInput']
    # upsert: List['LidarUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['LidarCreateOrConnectWithoutRelationsInput']


class LidarUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LidarCreateWithoutRelationsInput'
    connect: 'LidarWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LidarUpdateInput'
    # upsert: 'LidarUpsertWithoutRelationsInput'
    # connectOrCreate: 'LidarCreateOrConnectWithoutRelationsInput'


class LidarUpsertInput(TypedDict):
    create: 'LidarCreateInput'
    update: 'LidarUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Lidar_id_OrderByInput = TypedDict(
    '_Lidar_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Lidar_turtleBotId_OrderByInput = TypedDict(
    '_Lidar_turtleBotId_OrderByInput',
    {
        'turtleBotId': 'SortOrder',
    },
    total=True
)

_Lidar_timestamp_OrderByInput = TypedDict(
    '_Lidar_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_Lidar_scan_OrderByInput = TypedDict(
    '_Lidar_scan_OrderByInput',
    {
        'scan': 'SortOrder',
    },
    total=True
)

LidarOrderByInput = Union[
    '_Lidar_id_OrderByInput',
    '_Lidar_turtleBotId_OrderByInput',
    '_Lidar_timestamp_OrderByInput',
    '_Lidar_scan_OrderByInput',
]



# recursive Lidar types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

LidarRelationFilter = TypedDict(
    'LidarRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class LidarListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class LidarInclude(TypedDict, total=False):
    """Lidar relational arguments"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidar']


    

class TurtleBotIncludeFromLidar(TypedDict, total=False):
    """Relational arguments for Lidar"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromLidarRecursive1']
    battery: Union[bool, 'FindManyBatteryArgsFromLidarRecursive1']
    camera: Union[bool, 'FindManyCameraArgsFromLidarRecursive1']
    lidar: Union[bool, 'FindManyLidarArgsFromLidarRecursive1']
    waypoint: Union[bool, 'FindManyWaypointArgsFromLidarRecursive1']
    map: Union[bool, 'FindManyMapArgsFromLidarRecursive1']


class TurtleBotIncludeFromLidarRecursive1(TypedDict, total=False):
    """Relational arguments for Lidar"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromLidarRecursive2']
    battery: Union[bool, 'FindManyBatteryArgsFromLidarRecursive2']
    camera: Union[bool, 'FindManyCameraArgsFromLidarRecursive2']
    lidar: Union[bool, 'FindManyLidarArgsFromLidarRecursive2']
    waypoint: Union[bool, 'FindManyWaypointArgsFromLidarRecursive2']
    map: Union[bool, 'FindManyMapArgsFromLidarRecursive2']


class TurtleBotIncludeFromLidarRecursive2(TypedDict, total=False):
    """Relational arguments for Lidar"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromLidarRecursive3']
    battery: Union[bool, 'FindManyBatteryArgsFromLidarRecursive3']
    camera: Union[bool, 'FindManyCameraArgsFromLidarRecursive3']
    lidar: Union[bool, 'FindManyLidarArgsFromLidarRecursive3']
    waypoint: Union[bool, 'FindManyWaypointArgsFromLidarRecursive3']
    map: Union[bool, 'FindManyMapArgsFromLidarRecursive3']


class TurtleBotIncludeFromLidarRecursive3(TypedDict, total=False):
    """Relational arguments for Lidar"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromLidarRecursive4']
    battery: Union[bool, 'FindManyBatteryArgsFromLidarRecursive4']
    camera: Union[bool, 'FindManyCameraArgsFromLidarRecursive4']
    lidar: Union[bool, 'FindManyLidarArgsFromLidarRecursive4']
    waypoint: Union[bool, 'FindManyWaypointArgsFromLidarRecursive4']
    map: Union[bool, 'FindManyMapArgsFromLidarRecursive4']


class TurtleBotIncludeFromLidarRecursive4(TypedDict, total=False):
    """Relational arguments for Lidar"""

    

class TurtleBotArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class TurtleBotArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class TurtleBotArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class TurtleBotArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class TurtleBotArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    
    

class FindManyTurtleBotArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class FindManyTurtleBotArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class FindManyTurtleBotArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class FindManyTurtleBotArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class FindManyTurtleBotArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    
    

class TelemetryIncludeFromLidar(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive1']


class TelemetryIncludeFromLidarRecursive1(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive2']


class TelemetryIncludeFromLidarRecursive2(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive3']


class TelemetryIncludeFromLidarRecursive3(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive4']


class TelemetryIncludeFromLidarRecursive4(TypedDict, total=False):
    """Relational arguments for Lidar"""

    

class TelemetryArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class TelemetryArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class TelemetryArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class TelemetryArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class TelemetryArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    
    

class FindManyTelemetryArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class FindManyTelemetryArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class FindManyTelemetryArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class FindManyTelemetryArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class FindManyTelemetryArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    
    

class BatteryIncludeFromLidar(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive1']


class BatteryIncludeFromLidarRecursive1(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive2']


class BatteryIncludeFromLidarRecursive2(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive3']


class BatteryIncludeFromLidarRecursive3(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive4']


class BatteryIncludeFromLidarRecursive4(TypedDict, total=False):
    """Relational arguments for Lidar"""

    

class BatteryArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'BatteryIncludeFromBatteryRecursive1'


class BatteryArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'BatteryIncludeFromBatteryRecursive2'


class BatteryArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'BatteryIncludeFromBatteryRecursive3'


class BatteryArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'BatteryIncludeFromBatteryRecursive4'


class BatteryArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    
    

class FindManyBatteryArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive1'


class FindManyBatteryArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive2'


class FindManyBatteryArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive3'


class FindManyBatteryArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive4'


class FindManyBatteryArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    
    

class CameraIncludeFromLidar(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive1']


class CameraIncludeFromLidarRecursive1(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive2']


class CameraIncludeFromLidarRecursive2(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive3']


class CameraIncludeFromLidarRecursive3(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive4']


class CameraIncludeFromLidarRecursive4(TypedDict, total=False):
    """Relational arguments for Lidar"""

    

class CameraArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'CameraIncludeFromCameraRecursive1'


class CameraArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'CameraIncludeFromCameraRecursive2'


class CameraArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'CameraIncludeFromCameraRecursive3'


class CameraArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'CameraIncludeFromCameraRecursive4'


class CameraArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    
    

class FindManyCameraArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive1'


class FindManyCameraArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive2'


class FindManyCameraArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive3'


class FindManyCameraArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive4'


class FindManyCameraArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    
    

class LidarIncludeFromLidar(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive1']


class LidarIncludeFromLidarRecursive1(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive2']


class LidarIncludeFromLidarRecursive2(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive3']


class LidarIncludeFromLidarRecursive3(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive4']


class LidarIncludeFromLidarRecursive4(TypedDict, total=False):
    """Relational arguments for Lidar"""

    

class LidarArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'LidarIncludeFromLidarRecursive1'


class LidarArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'LidarIncludeFromLidarRecursive2'


class LidarArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'LidarIncludeFromLidarRecursive3'


class LidarArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'LidarIncludeFromLidarRecursive4'


class LidarArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    
    

class FindManyLidarArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive1'


class FindManyLidarArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive2'


class FindManyLidarArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive3'


class FindManyLidarArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive4'


class FindManyLidarArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    
    

class WaypointIncludeFromLidar(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive1']


class WaypointIncludeFromLidarRecursive1(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive2']


class WaypointIncludeFromLidarRecursive2(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive3']


class WaypointIncludeFromLidarRecursive3(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive4']


class WaypointIncludeFromLidarRecursive4(TypedDict, total=False):
    """Relational arguments for Lidar"""

    

class WaypointArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'WaypointIncludeFromWaypointRecursive1'


class WaypointArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'WaypointIncludeFromWaypointRecursive2'


class WaypointArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'WaypointIncludeFromWaypointRecursive3'


class WaypointArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'WaypointIncludeFromWaypointRecursive4'


class WaypointArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    
    

class FindManyWaypointArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive1'


class FindManyWaypointArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive2'


class FindManyWaypointArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive3'


class FindManyWaypointArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive4'


class FindManyWaypointArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    
    

class MapIncludeFromLidar(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive1']


class MapIncludeFromLidarRecursive1(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive2']


class MapIncludeFromLidarRecursive2(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive3']


class MapIncludeFromLidarRecursive3(TypedDict, total=False):
    """Relational arguments for Lidar"""
    turtleBot: Union[bool, 'TurtleBotArgsFromLidarRecursive4']


class MapIncludeFromLidarRecursive4(TypedDict, total=False):
    """Relational arguments for Lidar"""

    

class MapArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'MapIncludeFromMapRecursive1'


class MapArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'MapIncludeFromMapRecursive2'


class MapArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'MapIncludeFromMapRecursive3'


class MapArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    include: 'MapIncludeFromMapRecursive4'


class MapArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    
    

class FindManyMapArgsFromLidar(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive1'


class FindManyMapArgsFromLidarRecursive1(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive2'


class FindManyMapArgsFromLidarRecursive2(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive3'


class FindManyMapArgsFromLidarRecursive3(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive4'


class FindManyMapArgsFromLidarRecursive4(TypedDict, total=False):
    """Arguments for Lidar"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    


FindManyLidarArgs = FindManyLidarArgsFromLidar
FindFirstLidarArgs = FindManyLidarArgsFromLidar


    

class LidarWhereInput(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    scan: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['LidarWhereInputRecursive1', List['LidarWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['LidarWhereInputRecursive1']
    OR: List['LidarWhereInputRecursive1']
    NOT: List['LidarWhereInputRecursive1']


class LidarWhereInputRecursive1(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    scan: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['LidarWhereInputRecursive2', List['LidarWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['LidarWhereInputRecursive2']
    OR: List['LidarWhereInputRecursive2']
    NOT: List['LidarWhereInputRecursive2']


class LidarWhereInputRecursive2(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    scan: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['LidarWhereInputRecursive3', List['LidarWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['LidarWhereInputRecursive3']
    OR: List['LidarWhereInputRecursive3']
    NOT: List['LidarWhereInputRecursive3']


class LidarWhereInputRecursive3(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    scan: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['LidarWhereInputRecursive4', List['LidarWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['LidarWhereInputRecursive4']
    OR: List['LidarWhereInputRecursive4']
    NOT: List['LidarWhereInputRecursive4']


class LidarWhereInputRecursive4(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    scan: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'



# aggregate Lidar types


    

class LidarScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scan: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LidarScalarWhereWithAggregatesInputRecursive1']
    OR: List['LidarScalarWhereWithAggregatesInputRecursive1']
    NOT: List['LidarScalarWhereWithAggregatesInputRecursive1']


class LidarScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scan: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LidarScalarWhereWithAggregatesInputRecursive2']
    OR: List['LidarScalarWhereWithAggregatesInputRecursive2']
    NOT: List['LidarScalarWhereWithAggregatesInputRecursive2']


class LidarScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scan: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LidarScalarWhereWithAggregatesInputRecursive3']
    OR: List['LidarScalarWhereWithAggregatesInputRecursive3']
    NOT: List['LidarScalarWhereWithAggregatesInputRecursive3']


class LidarScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scan: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LidarScalarWhereWithAggregatesInputRecursive4']
    OR: List['LidarScalarWhereWithAggregatesInputRecursive4']
    NOT: List['LidarScalarWhereWithAggregatesInputRecursive4']


class LidarScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Lidar arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scan: Union[_str, 'types.StringWithAggregatesFilter']



class LidarGroupByOutput(TypedDict, total=False):
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    scan: _str
    _sum: 'LidarSumAggregateOutput'
    _avg: 'LidarAvgAggregateOutput'
    _min: 'LidarMinAggregateOutput'
    _max: 'LidarMaxAggregateOutput'
    _count: 'LidarCountAggregateOutput'


class LidarAvgAggregateOutput(TypedDict, total=False):
    """Lidar output for aggregating averages"""
    id: float
    turtleBotId: float


class LidarSumAggregateOutput(TypedDict, total=False):
    """Lidar output for aggregating sums"""
    id: _int
    turtleBotId: _int


class LidarScalarAggregateOutput(TypedDict, total=False):
    """Lidar output including scalar fields"""
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    scan: _str


LidarMinAggregateOutput = LidarScalarAggregateOutput
LidarMaxAggregateOutput = LidarScalarAggregateOutput


class LidarMaxAggregateInput(TypedDict, total=False):
    """Lidar input for aggregating by max"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    scan: bool


class LidarMinAggregateInput(TypedDict, total=False):
    """Lidar input for aggregating by min"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    scan: bool


class LidarNumberAggregateInput(TypedDict, total=False):
    """Lidar input for aggregating numbers"""
    id: bool
    turtleBotId: bool


LidarAvgAggregateInput = LidarNumberAggregateInput
LidarSumAggregateInput = LidarNumberAggregateInput


LidarCountAggregateInput = TypedDict(
    'LidarCountAggregateInput',
    {
        'id': bool,
        'turtleBotId': bool,
        'timestamp': bool,
        'scan': bool,
        '_all': bool,
    },
    total=False,
)

LidarCountAggregateOutput = TypedDict(
    'LidarCountAggregateOutput',
    {
        'id': int,
        'turtleBotId': int,
        'timestamp': int,
        'scan': int,
        '_all': int,
    },
    total=False,
)


LidarKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'scan',
    'turtleBot',
]
LidarScalarFieldKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'scan',
]
LidarScalarFieldKeysT = TypeVar('LidarScalarFieldKeysT', bound=LidarScalarFieldKeys)

LidarRelationalFieldKeys = Literal[
        'turtleBot',
    ]

# Waypoint types

class WaypointOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Waypoint create method"""
    id: _int
    turtleBotId: _int
    turtleBot: 'TurtleBotCreateNestedWithoutRelationsInput'


class WaypointCreateInput(WaypointOptionalCreateInput):
    """Required arguments to the Waypoint create method"""
    timestamp: datetime.datetime
    x: _float
    y: _float
    theta: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class WaypointOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Waypoint create method, without relations"""
    id: _int
    turtleBotId: _int


class WaypointCreateWithoutRelationsInput(WaypointOptionalCreateWithoutRelationsInput):
    """Required arguments to the Waypoint create method, without relations"""
    timestamp: datetime.datetime
    x: _float
    y: _float
    theta: _float


class WaypointCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'WaypointCreateWithoutRelationsInput'
    connect: 'WaypointWhereUniqueInput'


class WaypointCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['WaypointCreateWithoutRelationsInput', List['WaypointCreateWithoutRelationsInput']]
    connect: Union['WaypointWhereUniqueInput', List['WaypointWhereUniqueInput']]


_WaypointWhereUnique_id_Input = TypedDict(
    '_WaypointWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

WaypointWhereUniqueInput = _WaypointWhereUnique_id_Input


class WaypointUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    x: Union[AtomicFloatInput, _float]
    y: Union[AtomicFloatInput, _float]
    theta: Union[AtomicFloatInput, _float]
    turtleBot: 'TurtleBotUpdateOneWithoutRelationsInput'


class WaypointUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    x: Union[AtomicFloatInput, _float]
    y: Union[AtomicFloatInput, _float]
    theta: Union[AtomicFloatInput, _float]


class WaypointUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['WaypointCreateWithoutRelationsInput']
    connect: List['WaypointWhereUniqueInput']
    set: List['WaypointWhereUniqueInput']
    disconnect: List['WaypointWhereUniqueInput']
    delete: List['WaypointWhereUniqueInput']

    # TODO
    # update: List['WaypointUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['WaypointUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['WaypointScalarWhereInput']
    # upsert: List['WaypointUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['WaypointCreateOrConnectWithoutRelationsInput']


class WaypointUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'WaypointCreateWithoutRelationsInput'
    connect: 'WaypointWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'WaypointUpdateInput'
    # upsert: 'WaypointUpsertWithoutRelationsInput'
    # connectOrCreate: 'WaypointCreateOrConnectWithoutRelationsInput'


class WaypointUpsertInput(TypedDict):
    create: 'WaypointCreateInput'
    update: 'WaypointUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Waypoint_id_OrderByInput = TypedDict(
    '_Waypoint_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Waypoint_turtleBotId_OrderByInput = TypedDict(
    '_Waypoint_turtleBotId_OrderByInput',
    {
        'turtleBotId': 'SortOrder',
    },
    total=True
)

_Waypoint_timestamp_OrderByInput = TypedDict(
    '_Waypoint_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_Waypoint_x_OrderByInput = TypedDict(
    '_Waypoint_x_OrderByInput',
    {
        'x': 'SortOrder',
    },
    total=True
)

_Waypoint_y_OrderByInput = TypedDict(
    '_Waypoint_y_OrderByInput',
    {
        'y': 'SortOrder',
    },
    total=True
)

_Waypoint_theta_OrderByInput = TypedDict(
    '_Waypoint_theta_OrderByInput',
    {
        'theta': 'SortOrder',
    },
    total=True
)

WaypointOrderByInput = Union[
    '_Waypoint_id_OrderByInput',
    '_Waypoint_turtleBotId_OrderByInput',
    '_Waypoint_timestamp_OrderByInput',
    '_Waypoint_x_OrderByInput',
    '_Waypoint_y_OrderByInput',
    '_Waypoint_theta_OrderByInput',
]



# recursive Waypoint types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

WaypointRelationFilter = TypedDict(
    'WaypointRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class WaypointListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class WaypointInclude(TypedDict, total=False):
    """Waypoint relational arguments"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypoint']


    

class TurtleBotIncludeFromWaypoint(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromWaypointRecursive1']
    battery: Union[bool, 'FindManyBatteryArgsFromWaypointRecursive1']
    camera: Union[bool, 'FindManyCameraArgsFromWaypointRecursive1']
    lidar: Union[bool, 'FindManyLidarArgsFromWaypointRecursive1']
    waypoint: Union[bool, 'FindManyWaypointArgsFromWaypointRecursive1']
    map: Union[bool, 'FindManyMapArgsFromWaypointRecursive1']


class TurtleBotIncludeFromWaypointRecursive1(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromWaypointRecursive2']
    battery: Union[bool, 'FindManyBatteryArgsFromWaypointRecursive2']
    camera: Union[bool, 'FindManyCameraArgsFromWaypointRecursive2']
    lidar: Union[bool, 'FindManyLidarArgsFromWaypointRecursive2']
    waypoint: Union[bool, 'FindManyWaypointArgsFromWaypointRecursive2']
    map: Union[bool, 'FindManyMapArgsFromWaypointRecursive2']


class TurtleBotIncludeFromWaypointRecursive2(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromWaypointRecursive3']
    battery: Union[bool, 'FindManyBatteryArgsFromWaypointRecursive3']
    camera: Union[bool, 'FindManyCameraArgsFromWaypointRecursive3']
    lidar: Union[bool, 'FindManyLidarArgsFromWaypointRecursive3']
    waypoint: Union[bool, 'FindManyWaypointArgsFromWaypointRecursive3']
    map: Union[bool, 'FindManyMapArgsFromWaypointRecursive3']


class TurtleBotIncludeFromWaypointRecursive3(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromWaypointRecursive4']
    battery: Union[bool, 'FindManyBatteryArgsFromWaypointRecursive4']
    camera: Union[bool, 'FindManyCameraArgsFromWaypointRecursive4']
    lidar: Union[bool, 'FindManyLidarArgsFromWaypointRecursive4']
    waypoint: Union[bool, 'FindManyWaypointArgsFromWaypointRecursive4']
    map: Union[bool, 'FindManyMapArgsFromWaypointRecursive4']


class TurtleBotIncludeFromWaypointRecursive4(TypedDict, total=False):
    """Relational arguments for Waypoint"""

    

class TurtleBotArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class TurtleBotArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class TurtleBotArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class TurtleBotArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class TurtleBotArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    
    

class FindManyTurtleBotArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class FindManyTurtleBotArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class FindManyTurtleBotArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class FindManyTurtleBotArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class FindManyTurtleBotArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    
    

class TelemetryIncludeFromWaypoint(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive1']


class TelemetryIncludeFromWaypointRecursive1(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive2']


class TelemetryIncludeFromWaypointRecursive2(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive3']


class TelemetryIncludeFromWaypointRecursive3(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive4']


class TelemetryIncludeFromWaypointRecursive4(TypedDict, total=False):
    """Relational arguments for Waypoint"""

    

class TelemetryArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class TelemetryArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class TelemetryArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class TelemetryArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class TelemetryArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    
    

class FindManyTelemetryArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class FindManyTelemetryArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class FindManyTelemetryArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class FindManyTelemetryArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class FindManyTelemetryArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    
    

class BatteryIncludeFromWaypoint(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive1']


class BatteryIncludeFromWaypointRecursive1(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive2']


class BatteryIncludeFromWaypointRecursive2(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive3']


class BatteryIncludeFromWaypointRecursive3(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive4']


class BatteryIncludeFromWaypointRecursive4(TypedDict, total=False):
    """Relational arguments for Waypoint"""

    

class BatteryArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'BatteryIncludeFromBatteryRecursive1'


class BatteryArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'BatteryIncludeFromBatteryRecursive2'


class BatteryArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'BatteryIncludeFromBatteryRecursive3'


class BatteryArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'BatteryIncludeFromBatteryRecursive4'


class BatteryArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    
    

class FindManyBatteryArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive1'


class FindManyBatteryArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive2'


class FindManyBatteryArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive3'


class FindManyBatteryArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive4'


class FindManyBatteryArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    
    

class CameraIncludeFromWaypoint(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive1']


class CameraIncludeFromWaypointRecursive1(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive2']


class CameraIncludeFromWaypointRecursive2(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive3']


class CameraIncludeFromWaypointRecursive3(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive4']


class CameraIncludeFromWaypointRecursive4(TypedDict, total=False):
    """Relational arguments for Waypoint"""

    

class CameraArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'CameraIncludeFromCameraRecursive1'


class CameraArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'CameraIncludeFromCameraRecursive2'


class CameraArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'CameraIncludeFromCameraRecursive3'


class CameraArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'CameraIncludeFromCameraRecursive4'


class CameraArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    
    

class FindManyCameraArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive1'


class FindManyCameraArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive2'


class FindManyCameraArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive3'


class FindManyCameraArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive4'


class FindManyCameraArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    
    

class LidarIncludeFromWaypoint(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive1']


class LidarIncludeFromWaypointRecursive1(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive2']


class LidarIncludeFromWaypointRecursive2(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive3']


class LidarIncludeFromWaypointRecursive3(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive4']


class LidarIncludeFromWaypointRecursive4(TypedDict, total=False):
    """Relational arguments for Waypoint"""

    

class LidarArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'LidarIncludeFromLidarRecursive1'


class LidarArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'LidarIncludeFromLidarRecursive2'


class LidarArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'LidarIncludeFromLidarRecursive3'


class LidarArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'LidarIncludeFromLidarRecursive4'


class LidarArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    
    

class FindManyLidarArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive1'


class FindManyLidarArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive2'


class FindManyLidarArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive3'


class FindManyLidarArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive4'


class FindManyLidarArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    
    

class WaypointIncludeFromWaypoint(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive1']


class WaypointIncludeFromWaypointRecursive1(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive2']


class WaypointIncludeFromWaypointRecursive2(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive3']


class WaypointIncludeFromWaypointRecursive3(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive4']


class WaypointIncludeFromWaypointRecursive4(TypedDict, total=False):
    """Relational arguments for Waypoint"""

    

class WaypointArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'WaypointIncludeFromWaypointRecursive1'


class WaypointArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'WaypointIncludeFromWaypointRecursive2'


class WaypointArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'WaypointIncludeFromWaypointRecursive3'


class WaypointArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'WaypointIncludeFromWaypointRecursive4'


class WaypointArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    
    

class FindManyWaypointArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive1'


class FindManyWaypointArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive2'


class FindManyWaypointArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive3'


class FindManyWaypointArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive4'


class FindManyWaypointArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    
    

class MapIncludeFromWaypoint(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive1']


class MapIncludeFromWaypointRecursive1(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive2']


class MapIncludeFromWaypointRecursive2(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive3']


class MapIncludeFromWaypointRecursive3(TypedDict, total=False):
    """Relational arguments for Waypoint"""
    turtleBot: Union[bool, 'TurtleBotArgsFromWaypointRecursive4']


class MapIncludeFromWaypointRecursive4(TypedDict, total=False):
    """Relational arguments for Waypoint"""

    

class MapArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'MapIncludeFromMapRecursive1'


class MapArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'MapIncludeFromMapRecursive2'


class MapArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'MapIncludeFromMapRecursive3'


class MapArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    include: 'MapIncludeFromMapRecursive4'


class MapArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    
    

class FindManyMapArgsFromWaypoint(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive1'


class FindManyMapArgsFromWaypointRecursive1(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive2'


class FindManyMapArgsFromWaypointRecursive2(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive3'


class FindManyMapArgsFromWaypointRecursive3(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive4'


class FindManyMapArgsFromWaypointRecursive4(TypedDict, total=False):
    """Arguments for Waypoint"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    


FindManyWaypointArgs = FindManyWaypointArgsFromWaypoint
FindFirstWaypointArgs = FindManyWaypointArgsFromWaypoint


    

class WaypointWhereInput(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    theta: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['WaypointWhereInputRecursive1', List['WaypointWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['WaypointWhereInputRecursive1']
    OR: List['WaypointWhereInputRecursive1']
    NOT: List['WaypointWhereInputRecursive1']


class WaypointWhereInputRecursive1(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    theta: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['WaypointWhereInputRecursive2', List['WaypointWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['WaypointWhereInputRecursive2']
    OR: List['WaypointWhereInputRecursive2']
    NOT: List['WaypointWhereInputRecursive2']


class WaypointWhereInputRecursive2(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    theta: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['WaypointWhereInputRecursive3', List['WaypointWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['WaypointWhereInputRecursive3']
    OR: List['WaypointWhereInputRecursive3']
    NOT: List['WaypointWhereInputRecursive3']


class WaypointWhereInputRecursive3(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    theta: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['WaypointWhereInputRecursive4', List['WaypointWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['WaypointWhereInputRecursive4']
    OR: List['WaypointWhereInputRecursive4']
    NOT: List['WaypointWhereInputRecursive4']


class WaypointWhereInputRecursive4(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    x: Union[_float, 'types.FloatFilter']
    y: Union[_float, 'types.FloatFilter']
    theta: Union[_float, 'types.FloatFilter']
    turtleBot: 'TurtleBotRelationFilter'



# aggregate Waypoint types


    

class WaypointScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    theta: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['WaypointScalarWhereWithAggregatesInputRecursive1']
    OR: List['WaypointScalarWhereWithAggregatesInputRecursive1']
    NOT: List['WaypointScalarWhereWithAggregatesInputRecursive1']


class WaypointScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    theta: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['WaypointScalarWhereWithAggregatesInputRecursive2']
    OR: List['WaypointScalarWhereWithAggregatesInputRecursive2']
    NOT: List['WaypointScalarWhereWithAggregatesInputRecursive2']


class WaypointScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    theta: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['WaypointScalarWhereWithAggregatesInputRecursive3']
    OR: List['WaypointScalarWhereWithAggregatesInputRecursive3']
    NOT: List['WaypointScalarWhereWithAggregatesInputRecursive3']


class WaypointScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    theta: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['WaypointScalarWhereWithAggregatesInputRecursive4']
    OR: List['WaypointScalarWhereWithAggregatesInputRecursive4']
    NOT: List['WaypointScalarWhereWithAggregatesInputRecursive4']


class WaypointScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Waypoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    x: Union[_float, 'types.FloatWithAggregatesFilter']
    y: Union[_float, 'types.FloatWithAggregatesFilter']
    theta: Union[_float, 'types.FloatWithAggregatesFilter']



class WaypointGroupByOutput(TypedDict, total=False):
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    x: _float
    y: _float
    theta: _float
    _sum: 'WaypointSumAggregateOutput'
    _avg: 'WaypointAvgAggregateOutput'
    _min: 'WaypointMinAggregateOutput'
    _max: 'WaypointMaxAggregateOutput'
    _count: 'WaypointCountAggregateOutput'


class WaypointAvgAggregateOutput(TypedDict, total=False):
    """Waypoint output for aggregating averages"""
    id: float
    turtleBotId: float
    x: float
    y: float
    theta: float


class WaypointSumAggregateOutput(TypedDict, total=False):
    """Waypoint output for aggregating sums"""
    id: _int
    turtleBotId: _int
    x: _float
    y: _float
    theta: _float


class WaypointScalarAggregateOutput(TypedDict, total=False):
    """Waypoint output including scalar fields"""
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    x: _float
    y: _float
    theta: _float


WaypointMinAggregateOutput = WaypointScalarAggregateOutput
WaypointMaxAggregateOutput = WaypointScalarAggregateOutput


class WaypointMaxAggregateInput(TypedDict, total=False):
    """Waypoint input for aggregating by max"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    x: bool
    y: bool
    theta: bool


class WaypointMinAggregateInput(TypedDict, total=False):
    """Waypoint input for aggregating by min"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    x: bool
    y: bool
    theta: bool


class WaypointNumberAggregateInput(TypedDict, total=False):
    """Waypoint input for aggregating numbers"""
    id: bool
    turtleBotId: bool
    x: bool
    y: bool
    theta: bool


WaypointAvgAggregateInput = WaypointNumberAggregateInput
WaypointSumAggregateInput = WaypointNumberAggregateInput


WaypointCountAggregateInput = TypedDict(
    'WaypointCountAggregateInput',
    {
        'id': bool,
        'turtleBotId': bool,
        'timestamp': bool,
        'x': bool,
        'y': bool,
        'theta': bool,
        '_all': bool,
    },
    total=False,
)

WaypointCountAggregateOutput = TypedDict(
    'WaypointCountAggregateOutput',
    {
        'id': int,
        'turtleBotId': int,
        'timestamp': int,
        'x': int,
        'y': int,
        'theta': int,
        '_all': int,
    },
    total=False,
)


WaypointKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'x',
    'y',
    'theta',
    'turtleBot',
]
WaypointScalarFieldKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'x',
    'y',
    'theta',
]
WaypointScalarFieldKeysT = TypeVar('WaypointScalarFieldKeysT', bound=WaypointScalarFieldKeys)

WaypointRelationalFieldKeys = Literal[
        'turtleBot',
    ]

# Map types

class MapOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Map create method"""
    id: _int
    turtleBotId: _int
    turtleBot: 'TurtleBotCreateNestedWithoutRelationsInput'


class MapCreateInput(MapOptionalCreateInput):
    """Required arguments to the Map create method"""
    timestamp: datetime.datetime
    data: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MapOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Map create method, without relations"""
    id: _int
    turtleBotId: _int


class MapCreateWithoutRelationsInput(MapOptionalCreateWithoutRelationsInput):
    """Required arguments to the Map create method, without relations"""
    timestamp: datetime.datetime
    data: _str


class MapCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MapCreateWithoutRelationsInput'
    connect: 'MapWhereUniqueInput'


class MapCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MapCreateWithoutRelationsInput', List['MapCreateWithoutRelationsInput']]
    connect: Union['MapWhereUniqueInput', List['MapWhereUniqueInput']]


_MapWhereUnique_id_Input = TypedDict(
    '_MapWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

MapWhereUniqueInput = _MapWhereUnique_id_Input


class MapUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    data: _str
    turtleBot: 'TurtleBotUpdateOneWithoutRelationsInput'


class MapUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    data: _str


class MapUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MapCreateWithoutRelationsInput']
    connect: List['MapWhereUniqueInput']
    set: List['MapWhereUniqueInput']
    disconnect: List['MapWhereUniqueInput']
    delete: List['MapWhereUniqueInput']

    # TODO
    # update: List['MapUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MapUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MapScalarWhereInput']
    # upsert: List['MapUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['MapCreateOrConnectWithoutRelationsInput']


class MapUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MapCreateWithoutRelationsInput'
    connect: 'MapWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MapUpdateInput'
    # upsert: 'MapUpsertWithoutRelationsInput'
    # connectOrCreate: 'MapCreateOrConnectWithoutRelationsInput'


class MapUpsertInput(TypedDict):
    create: 'MapCreateInput'
    update: 'MapUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Map_id_OrderByInput = TypedDict(
    '_Map_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Map_turtleBotId_OrderByInput = TypedDict(
    '_Map_turtleBotId_OrderByInput',
    {
        'turtleBotId': 'SortOrder',
    },
    total=True
)

_Map_timestamp_OrderByInput = TypedDict(
    '_Map_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_Map_data_OrderByInput = TypedDict(
    '_Map_data_OrderByInput',
    {
        'data': 'SortOrder',
    },
    total=True
)

MapOrderByInput = Union[
    '_Map_id_OrderByInput',
    '_Map_turtleBotId_OrderByInput',
    '_Map_timestamp_OrderByInput',
    '_Map_data_OrderByInput',
]



# recursive Map types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MapRelationFilter = TypedDict(
    'MapRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MapListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MapInclude(TypedDict, total=False):
    """Map relational arguments"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMap']


    

class TurtleBotIncludeFromMap(TypedDict, total=False):
    """Relational arguments for Map"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromMapRecursive1']
    battery: Union[bool, 'FindManyBatteryArgsFromMapRecursive1']
    camera: Union[bool, 'FindManyCameraArgsFromMapRecursive1']
    lidar: Union[bool, 'FindManyLidarArgsFromMapRecursive1']
    waypoint: Union[bool, 'FindManyWaypointArgsFromMapRecursive1']
    map: Union[bool, 'FindManyMapArgsFromMapRecursive1']


class TurtleBotIncludeFromMapRecursive1(TypedDict, total=False):
    """Relational arguments for Map"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromMapRecursive2']
    battery: Union[bool, 'FindManyBatteryArgsFromMapRecursive2']
    camera: Union[bool, 'FindManyCameraArgsFromMapRecursive2']
    lidar: Union[bool, 'FindManyLidarArgsFromMapRecursive2']
    waypoint: Union[bool, 'FindManyWaypointArgsFromMapRecursive2']
    map: Union[bool, 'FindManyMapArgsFromMapRecursive2']


class TurtleBotIncludeFromMapRecursive2(TypedDict, total=False):
    """Relational arguments for Map"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromMapRecursive3']
    battery: Union[bool, 'FindManyBatteryArgsFromMapRecursive3']
    camera: Union[bool, 'FindManyCameraArgsFromMapRecursive3']
    lidar: Union[bool, 'FindManyLidarArgsFromMapRecursive3']
    waypoint: Union[bool, 'FindManyWaypointArgsFromMapRecursive3']
    map: Union[bool, 'FindManyMapArgsFromMapRecursive3']


class TurtleBotIncludeFromMapRecursive3(TypedDict, total=False):
    """Relational arguments for Map"""
    telemetry: Union[bool, 'FindManyTelemetryArgsFromMapRecursive4']
    battery: Union[bool, 'FindManyBatteryArgsFromMapRecursive4']
    camera: Union[bool, 'FindManyCameraArgsFromMapRecursive4']
    lidar: Union[bool, 'FindManyLidarArgsFromMapRecursive4']
    waypoint: Union[bool, 'FindManyWaypointArgsFromMapRecursive4']
    map: Union[bool, 'FindManyMapArgsFromMapRecursive4']


class TurtleBotIncludeFromMapRecursive4(TypedDict, total=False):
    """Relational arguments for Map"""

    

class TurtleBotArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class TurtleBotArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class TurtleBotArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class TurtleBotArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class TurtleBotArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    
    

class FindManyTurtleBotArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive1'


class FindManyTurtleBotArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive2'


class FindManyTurtleBotArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive3'


class FindManyTurtleBotArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    include: 'TurtleBotIncludeFromTurtleBotRecursive4'


class FindManyTurtleBotArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TurtleBotOrderByInput', List['TurtleBotOrderByInput']]
    where: 'TurtleBotWhereInput'
    cursor: 'TurtleBotWhereUniqueInput'
    distinct: List['TurtleBotScalarFieldKeys']
    
    

class TelemetryIncludeFromMap(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive1']


class TelemetryIncludeFromMapRecursive1(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive2']


class TelemetryIncludeFromMapRecursive2(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive3']


class TelemetryIncludeFromMapRecursive3(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive4']


class TelemetryIncludeFromMapRecursive4(TypedDict, total=False):
    """Relational arguments for Map"""

    

class TelemetryArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class TelemetryArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class TelemetryArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class TelemetryArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class TelemetryArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    
    

class FindManyTelemetryArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive1'


class FindManyTelemetryArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive2'


class FindManyTelemetryArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive3'


class FindManyTelemetryArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    include: 'TelemetryIncludeFromTelemetryRecursive4'


class FindManyTelemetryArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['TelemetryOrderByInput', List['TelemetryOrderByInput']]
    where: 'TelemetryWhereInput'
    cursor: 'TelemetryWhereUniqueInput'
    distinct: List['TelemetryScalarFieldKeys']
    
    

class BatteryIncludeFromMap(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive1']


class BatteryIncludeFromMapRecursive1(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive2']


class BatteryIncludeFromMapRecursive2(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive3']


class BatteryIncludeFromMapRecursive3(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive4']


class BatteryIncludeFromMapRecursive4(TypedDict, total=False):
    """Relational arguments for Map"""

    

class BatteryArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    include: 'BatteryIncludeFromBatteryRecursive1'


class BatteryArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    include: 'BatteryIncludeFromBatteryRecursive2'


class BatteryArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    include: 'BatteryIncludeFromBatteryRecursive3'


class BatteryArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    include: 'BatteryIncludeFromBatteryRecursive4'


class BatteryArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    
    

class FindManyBatteryArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive1'


class FindManyBatteryArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive2'


class FindManyBatteryArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive3'


class FindManyBatteryArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    include: 'BatteryIncludeFromBatteryRecursive4'


class FindManyBatteryArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['BatteryOrderByInput', List['BatteryOrderByInput']]
    where: 'BatteryWhereInput'
    cursor: 'BatteryWhereUniqueInput'
    distinct: List['BatteryScalarFieldKeys']
    
    

class CameraIncludeFromMap(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive1']


class CameraIncludeFromMapRecursive1(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive2']


class CameraIncludeFromMapRecursive2(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive3']


class CameraIncludeFromMapRecursive3(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive4']


class CameraIncludeFromMapRecursive4(TypedDict, total=False):
    """Relational arguments for Map"""

    

class CameraArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    include: 'CameraIncludeFromCameraRecursive1'


class CameraArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    include: 'CameraIncludeFromCameraRecursive2'


class CameraArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    include: 'CameraIncludeFromCameraRecursive3'


class CameraArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    include: 'CameraIncludeFromCameraRecursive4'


class CameraArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    
    

class FindManyCameraArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive1'


class FindManyCameraArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive2'


class FindManyCameraArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive3'


class FindManyCameraArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    include: 'CameraIncludeFromCameraRecursive4'


class FindManyCameraArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['CameraOrderByInput', List['CameraOrderByInput']]
    where: 'CameraWhereInput'
    cursor: 'CameraWhereUniqueInput'
    distinct: List['CameraScalarFieldKeys']
    
    

class LidarIncludeFromMap(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive1']


class LidarIncludeFromMapRecursive1(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive2']


class LidarIncludeFromMapRecursive2(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive3']


class LidarIncludeFromMapRecursive3(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive4']


class LidarIncludeFromMapRecursive4(TypedDict, total=False):
    """Relational arguments for Map"""

    

class LidarArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    include: 'LidarIncludeFromLidarRecursive1'


class LidarArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    include: 'LidarIncludeFromLidarRecursive2'


class LidarArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    include: 'LidarIncludeFromLidarRecursive3'


class LidarArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    include: 'LidarIncludeFromLidarRecursive4'


class LidarArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    
    

class FindManyLidarArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive1'


class FindManyLidarArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive2'


class FindManyLidarArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive3'


class FindManyLidarArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    include: 'LidarIncludeFromLidarRecursive4'


class FindManyLidarArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['LidarOrderByInput', List['LidarOrderByInput']]
    where: 'LidarWhereInput'
    cursor: 'LidarWhereUniqueInput'
    distinct: List['LidarScalarFieldKeys']
    
    

class WaypointIncludeFromMap(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive1']


class WaypointIncludeFromMapRecursive1(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive2']


class WaypointIncludeFromMapRecursive2(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive3']


class WaypointIncludeFromMapRecursive3(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive4']


class WaypointIncludeFromMapRecursive4(TypedDict, total=False):
    """Relational arguments for Map"""

    

class WaypointArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    include: 'WaypointIncludeFromWaypointRecursive1'


class WaypointArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    include: 'WaypointIncludeFromWaypointRecursive2'


class WaypointArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    include: 'WaypointIncludeFromWaypointRecursive3'


class WaypointArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    include: 'WaypointIncludeFromWaypointRecursive4'


class WaypointArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    
    

class FindManyWaypointArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive1'


class FindManyWaypointArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive2'


class FindManyWaypointArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive3'


class FindManyWaypointArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    include: 'WaypointIncludeFromWaypointRecursive4'


class FindManyWaypointArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['WaypointOrderByInput', List['WaypointOrderByInput']]
    where: 'WaypointWhereInput'
    cursor: 'WaypointWhereUniqueInput'
    distinct: List['WaypointScalarFieldKeys']
    
    

class MapIncludeFromMap(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive1']


class MapIncludeFromMapRecursive1(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive2']


class MapIncludeFromMapRecursive2(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive3']


class MapIncludeFromMapRecursive3(TypedDict, total=False):
    """Relational arguments for Map"""
    turtleBot: Union[bool, 'TurtleBotArgsFromMapRecursive4']


class MapIncludeFromMapRecursive4(TypedDict, total=False):
    """Relational arguments for Map"""

    

class MapArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    include: 'MapIncludeFromMapRecursive1'


class MapArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    include: 'MapIncludeFromMapRecursive2'


class MapArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    include: 'MapIncludeFromMapRecursive3'


class MapArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    include: 'MapIncludeFromMapRecursive4'


class MapArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    
    

class FindManyMapArgsFromMap(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive1'


class FindManyMapArgsFromMapRecursive1(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive2'


class FindManyMapArgsFromMapRecursive2(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive3'


class FindManyMapArgsFromMapRecursive3(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    include: 'MapIncludeFromMapRecursive4'


class FindManyMapArgsFromMapRecursive4(TypedDict, total=False):
    """Arguments for Map"""
    take: int
    skip: int
    order_by: Union['MapOrderByInput', List['MapOrderByInput']]
    where: 'MapWhereInput'
    cursor: 'MapWhereUniqueInput'
    distinct: List['MapScalarFieldKeys']
    


FindManyMapArgs = FindManyMapArgsFromMap
FindFirstMapArgs = FindManyMapArgsFromMap


    

class MapWhereInput(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    data: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['MapWhereInputRecursive1', List['MapWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MapWhereInputRecursive1']
    OR: List['MapWhereInputRecursive1']
    NOT: List['MapWhereInputRecursive1']


class MapWhereInputRecursive1(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    data: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['MapWhereInputRecursive2', List['MapWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MapWhereInputRecursive2']
    OR: List['MapWhereInputRecursive2']
    NOT: List['MapWhereInputRecursive2']


class MapWhereInputRecursive2(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    data: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['MapWhereInputRecursive3', List['MapWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MapWhereInputRecursive3']
    OR: List['MapWhereInputRecursive3']
    NOT: List['MapWhereInputRecursive3']


class MapWhereInputRecursive3(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    data: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'

    # should be noted that AND and NOT should be Union['MapWhereInputRecursive4', List['MapWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MapWhereInputRecursive4']
    OR: List['MapWhereInputRecursive4']
    NOT: List['MapWhereInputRecursive4']


class MapWhereInputRecursive4(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    turtleBotId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    data: Union[_str, 'types.StringFilter']
    turtleBot: 'TurtleBotRelationFilter'



# aggregate Map types


    

class MapScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MapScalarWhereWithAggregatesInputRecursive1']
    OR: List['MapScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MapScalarWhereWithAggregatesInputRecursive1']


class MapScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MapScalarWhereWithAggregatesInputRecursive2']
    OR: List['MapScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MapScalarWhereWithAggregatesInputRecursive2']


class MapScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MapScalarWhereWithAggregatesInputRecursive3']
    OR: List['MapScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MapScalarWhereWithAggregatesInputRecursive3']


class MapScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MapScalarWhereWithAggregatesInputRecursive4']
    OR: List['MapScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MapScalarWhereWithAggregatesInputRecursive4']


class MapScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Map arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    turtleBotId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    data: Union[_str, 'types.StringWithAggregatesFilter']



class MapGroupByOutput(TypedDict, total=False):
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    data: _str
    _sum: 'MapSumAggregateOutput'
    _avg: 'MapAvgAggregateOutput'
    _min: 'MapMinAggregateOutput'
    _max: 'MapMaxAggregateOutput'
    _count: 'MapCountAggregateOutput'


class MapAvgAggregateOutput(TypedDict, total=False):
    """Map output for aggregating averages"""
    id: float
    turtleBotId: float


class MapSumAggregateOutput(TypedDict, total=False):
    """Map output for aggregating sums"""
    id: _int
    turtleBotId: _int


class MapScalarAggregateOutput(TypedDict, total=False):
    """Map output including scalar fields"""
    id: _int
    turtleBotId: _int
    timestamp: datetime.datetime
    data: _str


MapMinAggregateOutput = MapScalarAggregateOutput
MapMaxAggregateOutput = MapScalarAggregateOutput


class MapMaxAggregateInput(TypedDict, total=False):
    """Map input for aggregating by max"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    data: bool


class MapMinAggregateInput(TypedDict, total=False):
    """Map input for aggregating by min"""
    id: bool
    turtleBotId: bool
    timestamp: bool
    data: bool


class MapNumberAggregateInput(TypedDict, total=False):
    """Map input for aggregating numbers"""
    id: bool
    turtleBotId: bool


MapAvgAggregateInput = MapNumberAggregateInput
MapSumAggregateInput = MapNumberAggregateInput


MapCountAggregateInput = TypedDict(
    'MapCountAggregateInput',
    {
        'id': bool,
        'turtleBotId': bool,
        'timestamp': bool,
        'data': bool,
        '_all': bool,
    },
    total=False,
)

MapCountAggregateOutput = TypedDict(
    'MapCountAggregateOutput',
    {
        'id': int,
        'turtleBotId': int,
        'timestamp': int,
        'data': int,
        '_all': int,
    },
    total=False,
)


MapKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'data',
    'turtleBot',
]
MapScalarFieldKeys = Literal[
    'id',
    'turtleBotId',
    'timestamp',
    'data',
]
MapScalarFieldKeysT = TypeVar('MapScalarFieldKeysT', bound=MapScalarFieldKeys)

MapRelationalFieldKeys = Literal[
        'turtleBot',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields